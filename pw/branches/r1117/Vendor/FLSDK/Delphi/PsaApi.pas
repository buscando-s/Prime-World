//
//  PsaApi.pas
//
//  File description:
//      Unit for public API functions. These functions can be used in
//      initialization module as well as in protected application.
//
//  Notes:
//      Detailed info about functions and parameters see in PsaApi.h.
//

unit PsaApi;

interface

uses
  Windows;

// Additional constants and definitions
{$I PsConfig}
{$I PsConstants}

// Additional types
type
  Size_T = Cardinal;
  PSize_T = ^Size_T;

// License version (see PSA_GetLicenseInformation)
const
  LIC_VERSION_UNDEFINED                             = $FFFFFFFF;
  LIC_VERSION_0_DISC                                = 0;
  LIC_VERSION_1_HARDWARE                            = 1;

// License types (see PSA_GetLicenseInformation)
const
  LIC_TYPE_UNDEFINED                                = $FFFFFFFF;
  LIC_TYPE_HARDWARE                                 = 0;
  LIC_TYPE_HARDWARE_TRIAL                           = 1;
  LIC_TYPE_HARDWARE_RESCUE                          = 2;
  LIC_TYPE_HARDWARE_AUTOGENERATED_AFTER_DISC_CHECK  = 3;
  LIC_TYPE_DISC                                     = 4;

// Codes of independent features that can be granted by license
const
  PSA_GrantedFeature0                               = $00000001;
  PSA_GrantedFeature1                               = $00000002;
  PSA_GrantedFeature2                               = $00000004;
  PSA_GrantedFeature3                               = $00000008;
  PSA_GrantedFeature4                               = $00000010;
  PSA_GrantedFeature5                               = $00000020;
  PSA_GrantedFeature6                               = $00000040;
  PSA_GrantedFeature7                               = $00000080;
  PSA_GrantedFeature8                               = $00000100;
  PSA_GrantedFeature9                               = $00000200;
  PSA_GrantedFeature10                              = $00000400;
  PSA_GrantedFeature11                              = $00000800;
  PSA_GrantedFeature12                              = $00001000;
  PSA_GrantedFeature13                              = $00002000;
  PSA_GrantedFeature14                              = $00004000;
  PSA_GrantedFeature15                              = $00008000;
  PSA_GrantedFeature16                              = $00010000;
  PSA_GrantedFeature17                              = $00020000;
  PSA_GrantedFeature18                              = $00040000;
  PSA_GrantedFeature19                              = $00080000;
  PSA_GrantedFeature20                              = $00100000;
  PSA_GrantedFeature21                              = $00200000;
  PSA_GrantedFeature22                              = $00400000;
  PSA_GrantedFeature23                              = $00800000;
  PSA_GrantedFeature24                              = $01000000;
  PSA_GrantedFeature25                              = $02000000;
  PSA_GrantedFeature26                              = $04000000;
  PSA_GrantedFeature27                              = $08000000;
  PSA_GrantedFeature28                              = $10000000;
  PSA_GrantedFeature29                              = $20000000;
  PSA_GrantedFeature30                              = $40000000;
  PSA_GrantedFeature31                              = $80000000;

//
//	Common functions
//

// Dummy reference
procedure PSA_DummyFunction; stdcall; external 'protect.dll';

// Uninitialize protection core resources
function PSA_Uninitialize: Longword; stdcall; external 'protect.dll';

{$IFDEF PS_USE_LICENSES}

// Get registry path and base handle for license
function PSA_GetLicenseStoragePath(
  pathBuffer: PWideChar;
  pathBufferSizeInWideChars: PSize_T;
  registryBaseHandle: PHandle
  ): Longword; stdcall; external 'protect.dll';

// Get special information for current license
function PSA_GetLicenseInformation(
  licenseVersion: PLongword;
  licenseType: PLongword;
  nonCommercial: PBoolean
  ): Longword; stdcall; external 'protect.dll';

{$ENDIF}

//
//	Limitation of functionality
//

{$IFDEF PS_USE_LICENSES}

// Get a set of features granted by license (bit mask)
function PSA_GetFeaturesGrantedByLicense(
  features: PLongword
  ): Longword; stdcall; external 'protect.dll';

// Disable features granted by license
function PSA_DisableFeaturesGrantedByLicense(
  features: Longword
  ): Longword; stdcall; external 'protect.dll';

// Check rights granted by license and display error dialog on error
function PSA_CheckFeaturesGrantedByLicense(
  features: Longword
  ): Longword; stdcall; external 'protect.dll';

{$ENDIF}

//
//	Program start mode
//

{$IFDEF PS_USE_LICENSES}

// Check if the application is running in demo mode
function PSA_IsDemoMode(
  isDemoMode: PBoolean
  ): Longword; stdcall; external 'protect.dll';

// Check if the application is running in trial mode
function PSA_IsTrialMode(
  isTrialMode: PBoolean
  ): Longword; stdcall; external 'protect.dll';

{$ENDIF}

//
//	Expiration parameters of license
//

{$IFDEF PS_USE_LICENSES}

// Check if the license is already expired
function PSA_IsLicenseExpired(
  isLicenseExpired: PBoolean
  ): Longword; stdcall; external 'protect.dll';

// Get the time before expiration of license
function PSA_GetTimeToLicenseExpiration(
  timeToLicenseExpiration: PInt64
  ): Longword; stdcall; external 'protect.dll';

// Get date and time of license expiration
function PSA_GetLicenseExpirationDateTime(
  licenseExpirationDateTime: PInt64
  ): Longword; stdcall; external 'protect.dll';

// Get life time limit of license
function PSA_GetLicenseLifeTimeLimit(
  licenseLifeTimeLimit: PInt64
  ): Longword; stdcall; external 'protect.dll';

// Get remaining number of runs
function PSA_GetRemainingNumberOfRuns(
  remainingNumberOfRuns: PLongword
  ): Longword; stdcall; external 'protect.dll';

// Get limit for number of runs
function PSA_GetLicenseNumberOfRunsLimit(
  licenseNumberOfRunsLimit: PLongword
  ): Longword; stdcall; external 'protect.dll';

// Get remaining execution time of application, calculated in the current moment
function PSA_GetRemainingExecutionTime(
  remainingExecutionTime: PInt64
  ): Longword; stdcall; external 'protect.dll';

// Get remaining execution time of application, calculated in the moment of start of application
function PSA_GetRemainingExecutionTimeAtStart(
  remainingExecutinTimeAtStart: PInt64
  ): Longword; stdcall; external 'protect.dll';

// Get limit for execution time of application
function PSA_GetLicenseExecutionTimeLimit(
  licenseExecutionTimeLimit: PInt64
  ): Longword; stdcall; external 'protect.dll';

{$ENDIF}

//
//	User-defined data in the key
//

{$IFDEF PS_USE_LICENSES}

// Get user-defined field
function PSA_GetUserDefinedField16Bits(
  userDefinedField: PWord
  ): Longword; stdcall; external 'protect.dll';

{$ENDIF}

//
//	Specific functions for disc binding
//

{$IFDEF BINDING_DISC}

// Get the label of disc with that the check was passed
function PSA_GetDiscLabel(
  labelBuffer: PWideChar;
  labelBufferSizeInWideChars: PSize_T
  ): Longword; stdcall; external 'protect.dll';

{$ENDIF}

// 
// Specific functions for external binding
// 

{$IFDEF PS_EXTERNAL_BASED_INITIALIZATION_SUPPORTED}

//	Description:
//		Set external binding check success flag. By default flag 
//		is cleared.
//
//	Output:
//		Return value				- PSC_STATUS_SUCCESS
//
function PSA_ExternalBindingCheckSetSucceedFlag:
  Longword; stdcall; external 'protect.dll';

//	Description:
//		Clear external binding check success flag. By default flag 
//		is cleared.
//
//	Output:
//		Return value				- PSC_STATUS_SUCCESS
//
function  PSA_ExternalBindingCheckSetFailedFlag:
  Longword; stdcall; external 'protect.dll';

{$ENDIF}

{$IFDEF PS_SUPPORT_FILE_CHECK_API}

//  Description:
//		Returns result of loaded files checks
//  Input:
//		fileCheckResultOk 			- pointer to output variable
//									  set to true if all of protected files loaded not corrupted
//									  set to false if hash check for one or more files failed 
//	Output:
//		Return value				- PSC_STATUS_SUCCESS
function PSA_GetCheckFilesHashResult(
  fileCheckResultOk: PBoolean
  ): Longword; stdcall; external 'protect.dll';
{$ENDIF}

{$IFDEF PS_SUPPORT_MEMORY_CHECK_API}
//  Description:
//		Checks read only memory regions of protected modules, calculates hash and 
//		compare to hash value stored in protection library
//  Input:
//		memCheckResultOk 			- pointer to output variable
//									  set to true if read only memory for all protected modules remains unchanged
//									  set to false if memory changed for one or more modules
//	Output:
//		Return value				- PSC_STATUS_SUCCESS
function PSA_CheckProtectedModulesReadOnlyMem(
  memCheckResultOk: PBoolean
  ): Longword; stdcall; external 'protect.dll';

{$ENDIF}

implementation

// No implementation

end.
 
