//
//	PscApi.h
//
//	File description:
//		Header file for core API functions. These functions can be used in
//      initialization module. These functions MUST NOT be used in protected
//		application.
//

// Include this file only once
#pragma once

// Additional headers
#ifndef PS_CONFIG_H_INCLUDED_7D7370D6_8681_4908_8C5F_D1152CF38653
#define PS_CONFIG_H_INCLUDED_7D7370D6_8681_4908_8C5F_D1152CF38653
#include "PsConfig.h"
#endif
#ifndef PS_CONSTANTS_H_INCLUDED_7990EBEC_1968_44FF_AF44_6800920821F1
#define PS_CONSTANTS_H_INCLUDED_7990EBEC_1968_44FF_AF44_6800920821F1
#include "PsConstants.h"
#endif

//
//	Common initialization functions
//

// Start initialization (first service)
unsigned __int32 __stdcall PSC_StartInitialization(
	unsigned __int32 initializationType );

// Finish initialization
unsigned __int32 __stdcall PSC_FinishInitializationSuccess();

// Finish initialization
unsigned __int32 __stdcall PSC_FinishInitializationFailure();

// Uninitialization (last service)
unsigned __int32 __stdcall PSC_Uninitialize();

// Additional initialization at valid license
unsigned __int32 __stdcall PSC_PerformInitializationAtValidLicense();

// Initialization in demo mode
#ifdef PS_DEMO_MODE_SUPPORTED
unsigned __int32 __stdcall PSC_InitializeDemoMode();
#endif

//
//	Miscellaneous functions
//

// Get detailed error information
unsigned __int32 __stdcall PSC_GetErrorInformation(
	unsigned __int32 *infoBuffer,
	size_t *infoBufferSizeInElements,
	char *usedKeyBuffer,
	size_t *usedKeyBufferSizeInChars );

// Get license identifier
#ifdef PS_USE_LICENSES
unsigned __int32 __stdcall PSC_GetLicenseId(
	unsigned __int32 *identifier );
#endif

// Load localized string
unsigned __int32 __stdcall PSC_LoadString(
	unsigned __int32 stringId,
	wchar_t *stringBuffer,
	size_t *stringBufferSizeInWideChars );

// Enter global critical section (for license access)
unsigned __int32 __stdcall PSC_EnterGlobalCriticalSection();

// Leave global critical section (for license access)
unsigned __int32 __stdcall PSC_LeaveGlobalCriticalSection();

//
//	Functions for disc-based initialization
//

#if defined PS_DISC_BASED_INITIALIZATION_SUPPORTED || defined PS_DISC_WITH_BACKUP_BASED_INITIALIZATION_SUPPORTED

// Set preferred drive letter
unsigned __int32 __stdcall PSC_DiscSetPreferredDrive( 
	wchar_t driveLetter );

// Search disc and get label
unsigned __int32 __stdcall PSC_DiscSearchDisc2(
	char *labelBuffer,
	size_t *labelBufferSize,
	unsigned __int32 *type );

// Try to load disc license from registry
unsigned __int32 __stdcall PSC_DiscLoadLicenseFromRegistry(
	char *keyBuffer,
	size_t *keyBufferSize );

// Try to create disc license based on key written on the disc
unsigned __int32 __stdcall PSC_DiscCreateLicenseFromDisc();

// Test key and if it is valid create license and write it into system registry
unsigned __int32 __stdcall PSC_DiscTestNewKeyAndWriteLicenseForValidDiscKey(
	const char *key );

// Try rescue license (optionally preserve existed disc license)
unsigned __int32 __stdcall PSC_DiscTryRescueLicense(
	bool restoreExistedDiscLicenseOnError );

// Create or load rescue license and get hardware code
unsigned __int32 __stdcall PSC_DiscCreateOrLoadRescueLicenseAndGetHardwareCode(
	char *hardwareCodeBuffer,
	size_t *hardwareCodeBufferSize );

// Activate loaded rescue license
unsigned __int32 __stdcall PSC_DiscActivateAndStoreRescueLicense(
	const char *key );

// Try disc license (i.e. check disc)
unsigned __int32 __stdcall PSC_DiscTryDiscLicense();

// Create autogenerated license
#ifdef PS_BIND_TO_HARDWARE_AFTER_CD_SUCCESS
unsigned __int32 __stdcall PSC_DiscCreateAutogeneratedLicense();
#endif

// Try to check autogenerated license
#ifdef PS_BIND_TO_HARDWARE_AFTER_CD_SUCCESS
unsigned __int32 __stdcall PSC_DiscTryAutogeneratedLicense();
#endif

unsigned __int32 __stdcall PSC_DiscIsPreviousDiscCheckCrashed(
	bool *crashDetected );

#endif

//
//	Functions for computer-based initalization (activation)
//

#if defined PS_HARDWARE_BASED_INITIALIZATION_SUPPORTED || defined PS_DISC_WITH_BACKUP_BASED_INITIALIZATION_SUPPORTED

// Try to create/check trial license
#ifdef PS_TRIAL_PERIOD_SUPPORTED
unsigned __int32 __stdcall PSC_HardwareTryTrialLicense(
	bool createIfAbsent );
#endif

// Validate entered license number
unsigned __int32 __stdcall PSC_ValidateLicenseNumber(
	const char *licenseNumber,
	unsigned __int32 encodingId[ 4 ] );

// Try to check normal license (always resets previous license, on success sets new current license)
unsigned __int32 __stdcall PSC_HardwareTryNormalLicense(
	const char *licenseNumber );

#ifdef PS_SUM_LICENSES

// License position flags
#define PSC_PositionTypeFirst	1
#define PSC_PositionTypeLast	2

// Try and sum normal license (on error preserves previos lisense, on success adds current license data
// to previous and sets current lisense)
unsigned __int32 __stdcall PSC_HardwareAddNormalLicense(
	const char *licenseNumber, unsigned __int32 positionType );

#endif

// Create or load license, get hardware code
unsigned __int32 __stdcall PSC_HardwareCreateOrLoadNormalLicenseAndGetHardwareCode(
	const char *licenseNumber,
	char *hardwareCodeBuffer,
	size_t *hardwareCodeBufferSize );

// Activate current license
unsigned __int32 __stdcall PSC_HardwareActivateAndStoreNormalLicense(
	const char *key );

// Deactivate current license
#ifdef OPTION_ENABLE_DEACTIVATION
unsigned __int32 __stdcall PSC_HardwareDeactivateLicense( 
	const char *licenseNumber,
	char *hardwareCodeBuffer,
	size_t *hardwareCodeBufferSize );
#endif

#endif

//
//	Functions for server-based initialization
//

#ifdef PS_SERVER_BASED_INITIALIZATION_CLIENT

// Initialize new session
unsigned __int32 __stdcall PSC_SrvBndClientInitializeSession(
	UUID sessionGuid );

// Start session (get or restore license from server)
unsigned __int32 __stdcall PSC_SrvBndClientStartSession();

// Approve session
unsigned __int32 __stdcall PSC_SrvBndClientApproveSession();

// Finish and deinitialize session (get license back to the server and free resources)
unsigned __int32 __stdcall PSC_SrvBndClientFinishAndDeinitializeSession();

#endif

#ifdef PS_SERVER_BASED_INITIALIZATION_SERVER

// Process request
unsigned __int32 __stdcall PSC_SrvBndServerProcessRequest(
	unsigned __int32 languageId,
	char *requestDataBuffer,
	size_t requestDataBufferSize,
	char *responseDataBuffer,
	size_t *responseDataBufferSize );

#endif

//
// Functions for external binding initialization
//

#ifdef PS_EXTERNAL_BASED_INITIALIZATION_SUPPORTED

// Perform external binding check
unsigned __int32 __stdcall PSC_ExternalBindingCheck();

#endif

//
//	Hidden info remover (these functions are not accessible in user interface project)
//

#ifdef TRIAL_INFO_REMOVER

#ifdef PS_USE_LICENSES

// Remove trial information
#ifdef PS_TRIAL_PERIOD_SUPPORTED
unsigned __int32 __stdcall PSC_RemoveTrial();
#endif

// Remove history of license usage (number of runs, time of last run etc.)
unsigned __int32 __stdcall PSC_RemoveHistory();

// Remove all licenses including history
unsigned __int32 __stdcall PSC_RemoveAllLicenses();

// Remove hidden information about deactivated licenses
unsigned __int32 __stdcall PSC_RemoveHiddenDeactivationInfo();

#endif

#ifdef PS_SUPPORT_CERTIFICATE_CHECK

// Generate certificate
unsigned __int32 __stdcall PSC_CertificateGenerate( unsigned __int64 startDate, unsigned __int64 finishDate, const wchar_t *fileName );

#endif

#endif

//
//	Protection of documents
//

#ifdef OPTION_DATA_FILES_PROTECTION

// Try to open document
unsigned __int32 __stdcall PSC_DiscCheckDocument(
	HANDLE fileHandle,
	unsigned __int32 documentId[ 4 ],
	unsigned __int32 *errorCode );

// Try to open document
unsigned __int32 __stdcall PSC_HardwareCheckDocument(
	HANDLE fileHandle,
	unsigned __int32 documentId[ 4 ],
	unsigned __int32 *errorCode );

// Try to check normal license
unsigned __int32 __stdcall PSC_DiscTryRescueDocumentLicense(
	bool restoreExistedDiscLicenseOnError,
	HANDLE fileHandle,
	unsigned __int32 documentId[ 4 ],
	unsigned __int32 *errorCode );

unsigned __int32 __stdcall PSC_DiscTryDocumentLicense(
	HANDLE fileHandle,
	unsigned __int32 documentId[ 4 ],
	unsigned __int32 *errorCode );

// Try to check normal license
unsigned __int32 __stdcall PSC_HardwareTryDocumentLicense(
	HANDLE fileHandle,
	unsigned __int32 documentId[ 4 ],
	const char *licenseNumber,
	unsigned __int32 *errorCode );

// Create or load license, get hardware code
unsigned __int32 __stdcall PSC_HardwareCreateOrLoadDocumentLicenseAndGetHardwareCode(
	unsigned __int32 documentId[ 4 ],
	const char *licenseNumber,
	char *hardwareCodeBuffer,
	size_t *hardwareCodeBufferSize );

// Activate current license
unsigned __int32 __stdcall PSC_HardwareActivateAndStoreDocumentLicense(
	const char *key );

// Open protected document (complex function implemented in user interface project)
// Return values:
//   PSC_STATUS_SUCCESS - success
//   PSC_STATUS_BAD_FORMAT - the file is not protected document
//   Other return values for errors are also possible
unsigned __int32 __stdcall PSC_DocumentOpen( HANDLE documentFile );

#endif

//
//	Protection of documents (these functions are not accessible in user interface project)
//

#ifdef OPTION_DATA_FILES_PROTECTION

// Get size of protected document (hidden function: not exported from protect.dll in final version)
// Return values:
//   PSC_STATUS_SUCCESS - success (documentSize contains size of document)
//   Other return values for errors are also possible
unsigned __int32 __stdcall PSC_DocumentGetSize( HANDLE documentFile, size_t *documentSize );

// Get data (hidden function: not exported from protect.dll in final version)
// Return values:
//   PSC_STATUS_SUCCESS - success (dataBuffer will contain decrypted data block)
//   Other return values for errors are also possible
unsigned __int32 __stdcall PSC_DocumentGetData( HANDLE documentFile, void *dataBuffer, size_t dataOffset, size_t dataSize );

// Close protected document (hidden function: not exported from protect.dll in final version)
// Return values:
//   PSC_STATUS_SUCCESS - success
//   Other return values for errors are also possible
unsigned __int32 __stdcall PSC_DocumentClose( HANDLE documentFile );

#endif
