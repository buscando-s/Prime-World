#define PS_PROJECT_GUID_HASH
#define PS_PROJECT_GUID_HASH_A
#define PS_PROJECT_GUID_HASH_W
#define PS_PROJECT_GUID_HASH_RA
#define PS_PROJECT_GUID_HASH_RW
#define PS_PROJECT_GUID_HASH_OF_STRING
#define PS_PROJECT_GUID_HASH_OF_STRING_A
#define PS_PROJECT_GUID_HASH_OF_STRING_W
#define PS_PROJECT_GUID_HASH_OF_STRING_RA
#define PS_PROJECT_GUID_HASH_OF_STRING_RW
#define PS_ACTION_GUID_A
#define PS_ACTION_GUID_W
#define PS_ACTION_GUID_RA
#define PS_ACTION_GUID_RW
#define PS_BUILD_INFO_A
#define PS_BUILD_INFO_W
#define PS_BUILD_INFO_RA
#define PS_BUILD_INFO_RW
#define PS_VERSION_MAJOR
#define PS_VERSION_MINOR
#define PS_VERSION_BUILD
#define PS_VERSION_HOTFIX
#define PS_VERSION_A
#define PS_VERSION_W
#define PS_VERSION_RA
#define PS_VERSION_RW
#define PS_VERSION_MODULE_A
#define PS_VERSION_MODULE_W
#define PS_VERSION_MODULE_RA
#define PS_VERSION_MODULE_RW
#define PS_VERSION_PRODUCT_A
#define PS_VERSION_PRODUCT_W
#define PS_VERSION_PRODUCT_RA
#define PS_VERSION_PRODUCT_RW
#define PS_HOST_MODULE_NAME_A
#define PS_HOST_MODULE_NAME_W
#define PS_HOST_MODULE_NAME_RA
#define PS_HOST_MODULE_NAME_RW
#define PS_USER_INTERFACE_MODULE_NAME_A
#define PS_USER_INTERFACE_MODULE_NAME_W
#define PS_USER_INTERFACE_MODULE_NAME_RA
#define PS_USER_INTERFACE_MODULE_NAME_RW
#define PS_HELPER_MODULE_NAME_A
#define PS_HELPER_MODULE_NAME_W
#define PS_HELPER_MODULE_NAME_RA
#define PS_HELPER_MODULE_NAME_RW
#define SDK
#define PS_NO_BINDING_SUPPORTED
#define PS_BINDING_CHECK_LAST_RUN_TIME
#define PS_BINDING_CONTINUE_EXECUTION_AFTER_LICENSE_EXPIRATION
#define PS_BINDING_UPDATE_RUN_TIME_DATA_DURING_EXECUTION
#define PS_BINDING_CHECK_STARTUP_TIME
#define PS_SIMPLE_INITIALIZATION_SUPPORTED
#define PS_DEFAULT_INITIALIZATION_TYPE
#define PS_DRIVER_NAME_A
#define PS_DRIVER_NAME_W
#define PS_DRIVER_NAME_RA
#define PS_DRIVER_NAME_RW
#define PS_DRIVER_MODULE_NAME_A
#define PS_DRIVER_MODULE_NAME_W
#define PS_DRIVER_MODULE_NAME_RA
#define PS_DRIVER_MODULE_NAME_RW
#define PS_DRIVER_FRIENDLY_NAME_A
#define PS_DRIVER_FRIENDLY_NAME_W
#define PS_DRIVER_FRIENDLY_NAME_RA
#define PS_DRIVER_FRIENDLY_NAME_RW
#define PS_DRIVER_UNIQUE_FRIENDLY_NAME_A
#define PS_DRIVER_UNIQUE_FRIENDLY_NAME_W
#define PS_DRIVER_UNIQUE_FRIENDLY_NAME_RA
#define PS_DRIVER_UNIQUE_FRIENDLY_NAME_RW
#define PS_DRIVER_DEBUG_OUTPUT_PREFIX_A
#define PS_DRIVER_DEBUG_OUTPUT_PREFIX_W
#define PS_DRIVER_DEBUG_OUTPUT_PREFIX_RA
#define PS_DRIVER_DEBUG_OUTPUT_PREFIX_RW
#define PS_DRIVER_FS_NAME_A
#define PS_DRIVER_FS_NAME_W
#define PS_DRIVER_FS_NAME_RA
#define PS_DRIVER_FS_NAME_RW
#define PS_DRIVER_FS_MODULE_NAME_A
#define PS_DRIVER_FS_MODULE_NAME_W
#define PS_DRIVER_FS_MODULE_NAME_RA
#define PS_DRIVER_FS_MODULE_NAME_RW
#define PS_DRIVER_FS_FRIENDLY_NAME_A
#define PS_DRIVER_FS_FRIENDLY_NAME_W
#define PS_DRIVER_FS_FRIENDLY_NAME_RA
#define PS_DRIVER_FS_FRIENDLY_NAME_RW
#define PS_DRIVER_FS_UNIQUE_FRIENDLY_NAME_A
#define PS_DRIVER_FS_UNIQUE_FRIENDLY_NAME_W
#define PS_DRIVER_FS_UNIQUE_FRIENDLY_NAME_RA
#define PS_DRIVER_FS_UNIQUE_FRIENDLY_NAME_RW
#define PS_DRIVER_FS_DEBUG_OUTPUT_PREFIX_A
#define PS_DRIVER_FS_DEBUG_OUTPUT_PREFIX_W
#define PS_DRIVER_FS_DEBUG_OUTPUT_PREFIX_RA
#define PS_DRIVER_FS_DEBUG_OUTPUT_PREFIX_RW
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_NAME_A
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_NAME_W
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_NAME_RA
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_NAME_RW
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_MODULE_NAME_A
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_MODULE_NAME_W
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_MODULE_NAME_RA
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_MODULE_NAME_RW
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_FRIENDLY_NAME_A
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_FRIENDLY_NAME_W
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_FRIENDLY_NAME_RA
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_FRIENDLY_NAME_RW
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_UNIQUE_FRIENDLY_NAME_A
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_UNIQUE_FRIENDLY_NAME_W
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_UNIQUE_FRIENDLY_NAME_RA
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_UNIQUE_FRIENDLY_NAME_RW
#define PS_DRIVER_UPDATE_HOST_A
#define PS_DRIVER_UPDATE_HOST_W
#define PS_DRIVER_UPDATE_HOST_RA
#define PS_DRIVER_UPDATE_HOST_RW
#define PS_DRIVER_UPDATE_PORT_A
#define PS_DRIVER_UPDATE_PORT_W
#define PS_DRIVER_UPDATE_PORT_RA
#define PS_DRIVER_UPDATE_PORT_RW
#define PS_DRIVER_UPDATE_PATH_A
#define PS_DRIVER_UPDATE_PATH_W
#define PS_DRIVER_UPDATE_PATH_RA
#define PS_DRIVER_UPDATE_PATH_RW
#define OPTION_X8632_SUPPORT
#define PS_TARGET_PLATFORM_X8632
#define USER_KEY_REGISTRY_HKEY
#define USER_KEY_REGISTRY_PATH_A
#define USER_KEY_REGISTRY_PATH_W
#define USER_KEY_REGISTRY_PATH_RA
#define USER_KEY_REGISTRY_PATH_RW
#define RELEASE_TIME
#define PS_BINDING_NONE_NONCOMMERCIAL
#define PS_BINDING_NONE_NONCOMMERCIAL_LIFETIME
#define PS_NAG_SCREEN_HARDWARE_LIFE_TIME
#define PS_NAG_SCREEN_HARDWARE_NUMBER_OF_RUNS
#define PS_NAG_SCREEN_HARDWARE_EXECUTION_TIME
#define PS_COMPANY_NAME_A
#define PS_COMPANY_NAME_W
#define PS_COMPANY_NAME_RA
#define PS_COMPANY_NAME_RW
#define PS_PRODUCT_NAME_A
#define PS_PRODUCT_NAME_W
#define PS_PRODUCT_NAME_RA
#define PS_PRODUCT_NAME_RW
#define PS_COPYRIGHT_A
#define PS_COPYRIGHT_W
#define PS_COPYRIGHT_RA
#define PS_COPYRIGHT_RW
#define TRADE_NAME_A
#define TRADE_NAME_W
#define TRADE_NAME_RA
#define TRADE_NAME_RW
#define PS_GUI_SHOW_BUY_BUTTON
#define PS_SHOW_DEACTIVATION_HYPERLINK
#define PS_SHOW_PROGRESS_BAR
#define OPTION_DRVINSTALL_QUESTION
#define PS_DISPLAY_DRIVERS_FAQ
#define OPTION_GUI_USE_SHIFT_KEY_FOR_KEY_ENTERING
#define OPTION_GUI_USE_CONTROL_KEY_FOR_KEY_ENTERING
#define OPTION_COLLECT_SYSTEM_INFORMATION
#define PS_USER_CAN_SELECT_LANGUAGE
#define PS_SHOW_HELP
#define PS_BUILD_TYPE
#define PS_BUILD_TYPE_SPECIAL
#define PS_BUILD_TYPE_NAME_A
#define PS_BUILD_TYPE_NAME_W
#define PS_BUILD_TYPE_NAME_RA
#define PS_BUILD_TYPE_NAME_RW
#define OPTION_CHECK_PROTECTION_LIBRARY_HEADER
#define OPTION_DETECT_PC_EMULATORS
#define OPTION_RESTRICT_PROCESS_OWNERS
#define OPTION_USE_ERROR_STACK_SIGNATURE
#define PS_SUPPORT_CRYPTED_TRAFFIC
#define PS_APPLICATION_EVENT_LOG_NAME_A
#define PS_APPLICATION_EVENT_LOG_NAME_W
#define PS_APPLICATION_EVENT_LOG_NAME_RA
#define PS_APPLICATION_EVENT_LOG_NAME_RW
#define PS_PROTECTED_MODULES
#define PS_PROTECTION_LIBRARY_A
#define PS_PROTECTION_LIBRARY_W
#define PS_PROTECTION_LIBRARY_RA
#define PS_PROTECTION_LIBRARY_RW
#define PS_SET_FOREGROUND_WINDOW_UNDER_VISTA
#define OPTION_ALLOW_SYSTEM_DEBUGGERS
#define OPTION_ALLOW_USER_DEBUGGERS
#define MEMORY_MANAGER_RANDOMIZATION
#define PS_BUILD_FULL_PROJECT
//
//	PscApi.cs
//
//	File description:
//		Header file for core API functions. These functions can be used in
//      initialization module. These functions MUST NOT be used in protected
//		application.
//

using System;
using System.Text;
using System.Runtime.InteropServices;

namespace ProtectionApi
{
	class PscApi
	{
		//
		//	Common initialization functions
		//

		// Start initialization (first service)
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_StartInitialization( UInt32 initializationType );

		// Finish initialization
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_FinishInitializationSuccess();

		// Finish initialization
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_FinishInitializationFailure();

		// Uninitialization (last service)
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_Uninitialize();

		// Additional initialization at valid license
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_PerformInitializationAtValidLicense();

		// Initialization in demo mode
#if PS_DEMO_MODE_SUPPORTED
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_InitializeDemoMode();
#endif

		//
		//	Miscellaneous functions
		//

		// Get detailed error information
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_GetErrorInformation( [In, MarshalAs( UnmanagedType.LPArray, SizeParamIndex = 2 )]UInt32[] infoBuffer,
			ref int infoBufferSizeInElements,
			[In, MarshalAs( UnmanagedType.LPArray, SizeParamIndex = 4 )]Byte[] usedKeyBuffer,
			ref int usedKeyBufferSizeInChars );

		// Get license identifier
#if PS_USE_LICENSES
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_GetLicenseId( out UInt32 identifier );
#endif

		// Load localized string
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_LoadString( UInt32 stringId,
			[Out, MarshalAs( UnmanagedType.LPWStr )] StringBuilder stringBuffer,
			ref int stringBufferSizeInWideChars );

		// Enter global critical section (for license access)
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_EnterGlobalCriticalSection();

		// Leave global critical section (for license access)
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_LeaveGlobalCriticalSection();

		//
		//	Functions for disc-based initialization
		//

#if PS_DISC_BASED_INITIALIZATION_SUPPORTED || PS_DISC_WITH_BACKUP_BASED_INITIALIZATION_SUPPORTED

		// Search disc and get label
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_DiscSearchDisc2( [In, MarshalAs( UnmanagedType.LPArray, SizeParamIndex = 2 )]byte[] labelBuffer, ref int labelBufferSize );

		// Try to load disc license from registry
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_DiscLoadLicenseFromRegistry( [In, MarshalAs( UnmanagedType.LPArray, SizeParamIndex = 2 )]byte[] keyBuffer, ref int keyBufferSize );

		// Try to create disc license based on key written on the disc
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_DiscCreateLicenseFromDisc();

		// Test key and if it is valid create license and write it into system registry
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_DiscTestNewKeyAndWriteLicenseForValidDiscKey( [In, MarshalAs( UnmanagedType.LPArray )] byte[] key );

		// Try rescue license (optionally preserve existed disc license)
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_DiscTryRescueLicense( [In, MarshalAs(UnmanagedType.U1)]Boolean restoreExistedDiscLicenseOnError );

		// Create or load rescue license and get hardware code
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_DiscCreateOrLoadRescueLicenseAndGetHardwareCode(
			[In, MarshalAs( UnmanagedType.LPArray, SizeParamIndex = 2 )]byte[] hardwareCodeBuffer, ref int hardwareCodeBufferSize );

		// Activate loaded rescue license
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_DiscActivateAndStoreRescueLicense( byte[] key );

		// Try disc license (i.e. check disc)
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_DiscTryDiscLicense();

		// Create autogenerated license
#if PS_BIND_TO_HARDWARE_AFTER_CD_SUCCESS
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_DiscCreateAutogeneratedLicense();
#endif

		// Try to check autogenerated license
#if PS_BIND_TO_HARDWARE_AFTER_CD_SUCCESS
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		UInt32 PSC_DiscTryAutogeneratedLicense();
#endif

#endif

		//
		//	Functions for computer-based initalization (activation)
		//

#if PS_HARDWARE_BASED_INITIALIZATION_SUPPORTED || PS_DISC_WITH_BACKUP_BASED_INITIALIZATION_SUPPORTED

		// Try to create/check trial license
#if PS_TRIAL_PERIOD_SUPPORTED
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_HardwareTryTrialLicense(  [In, MarshalAs(UnmanagedType.U1)]Boolean createIfAbsent );
#endif

		// Validate entered license number
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_ValidateLicenseNumber(
			[In, MarshalAs( UnmanagedType.LPStr )]String licenseNumber, [In, MarshalAs( UnmanagedType.LPArray, SizeConst = 4 )]UInt32[] encodingId );

		// Try to check normal license
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_HardwareTryNormalLicense( [In, MarshalAs( UnmanagedType.LPStr )]String licenseNumber );

		// Create or load license, get hardware code
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_HardwareCreateOrLoadNormalLicenseAndGetHardwareCode(
			[In, MarshalAs( UnmanagedType.LPStr )]String licenseNumber,
			[In, MarshalAs( UnmanagedType.LPArray, SizeParamIndex = 3 )]byte[] hardwareCodeBuffer,
			ref int hardwareCodeBufferSize );

		// Activate current license
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_HardwareActivateAndStoreNormalLicense( [In, MarshalAs( UnmanagedType.LPStr )]String key );

		// Deactivate current license
#if OPTION_ENABLE_DEACTIVATION
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_HardwareDeactivateLicense( 
			[In, MarshalAs( UnmanagedType.LPStr )]String licenseNumber,
			[In, MarshalAs( UnmanagedType.LPArray, SizeParamIndex = 3 )]byte[] hardwareCodeBuffer,
			ref int hardwareCodeBufferSize );
#endif

#endif

		//
		//	Functions for server-based initialization
		//

#if PS_SERVER_BASED_INITIALIZATION_CLIENT

		// Initialize new session
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_SrvBndClientInitializeSession( UUID sessionGuid );

		// Start session (get or restore license from server)
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_SrvBndClientStartSession();

		// Approve session
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_SrvBndClientApproveSession();

		// Finish and deinitialize session (get license back to the server and free resources)
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_SrvBndClientFinishAndDeinitializeSession();

#endif

#if PS_SERVER_BASED_INITIALIZATION_SERVER

		// Process request
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_SrvBndServerProcessRequest(
			UInt32 languageId,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex=3)]byte[] requestDataBuffer,
			int requestDataBufferSize,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex=5)]byte[] responseDataBuffer,
			ref int responseDataBufferSize );

#endif

		//
		// Functions for external binding initialization
		//

#if PS_EXTERNAL_BASED_INITIALIZATION_SUPPORTED

		// Perform external binding check
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_ExternalBindingCheck();

#endif

		//
		//	Hidden info remover (these functions are not accessible in user interface project)
		//

#if TRIAL_INFO_REMOVER

		// Remove trial information
#if PS_TRIAL_PERIOD_SUPPORTED
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_RemoveTrial();
#endif

		// Remove history of license usage (number of runs, time of last run etc.)
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_RemoveHistory();

		// Remove all licenses including history
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_RemoveAllLicenses();

		// Remove hidden information about deactivated licenses
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_RemoveHiddenDeactivationInfo();

#endif

		//
		//	Protection of documents
		//

#if OPTION_DATA_FILES_PROTECTION

		// Try to open document
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_HardwareCheckDocument(
			IntPtr fileHandle,
			[In, MarshalAs(UnmanagedType.LPArray, SizeConst = 4)]UInt32[] documentId,
			ref UInt32 errorCode );

		// Try to check normal license
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_HardwareTryDocumentLicense(
			IntPtr fileHandle,
			[In, MarshalAs(UnmanagedType.LPArray, SizeConst = 4)]UInt32[] documentId,
			[In, MarshalAs(UnmanagedType.LPStr)]String licenseNumber,
			ref UInt32 errorCode );

		// Create or load license, get hardware code
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_HardwareCreateOrLoadDocumentLicenseAndGetHardwareCode(
			[In, MarshalAs(UnmanagedType.LPArray, SizeConst = 4)]UInt32[] documentId,
			[In, MarshalAs(UnmanagedType.LPStr)]String licenseNumber,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex=4)] byte[] hardwareCodeBuffer,
			ref int hardwareCodeBufferSize );

		// Activate current license
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_HardwareActivateAndStoreDocumentLicense(
			[In, MarshalAs(UnmanagedType.LPStr)]String key );

		// Open protected document (complex function implemented in user interface project)
		// Return values:
		//   PSC_STATUS_SUCCESS - success
		//   PSC_STATUS_BAD_FORMAT - the file is not protected document
		//   Other return values for errors are also possible
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_DocumentOpen( IntPtr documentFile );

#endif

		//
		//	Protection of documents (these functions are not accessible in user interface project)
		//

#if OPTION_DATA_FILES_PROTECTION

		// Get size of protected document (hidden function: not exported from protect.dll in final version)
		// Return values:
		//   PSC_STATUS_SUCCESS - success (documentSize contains size of document)
		//   Other return values for errors are also possible
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_DocumentGetSize( IntPtr documentFile, out int documentSize );

		// Get data (hidden function: not exported from protect.dll in final version)
		// Return values:
		//   PSC_STATUS_SUCCESS - success (dataBuffer will contain decrypted data block)
		//   Other return values for errors are also possible
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_DocumentGetData( IntPtr documentFile, [Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex=3 )]byte[] dataBuffer, int dataOffset, int dataSize );

		// Close protected document (hidden function: not exported from protect.dll in final version)
		// Return values:
		//   PSC_STATUS_SUCCESS - success
		//   Other return values for errors are also possible
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSC_DocumentClose( IntPtr documentFile );

#endif
	}
}
