#define PS_PROJECT_GUID_HASH
#define PS_PROJECT_GUID_HASH_A
#define PS_PROJECT_GUID_HASH_W
#define PS_PROJECT_GUID_HASH_RA
#define PS_PROJECT_GUID_HASH_RW
#define PS_PROJECT_GUID_HASH_OF_STRING
#define PS_PROJECT_GUID_HASH_OF_STRING_A
#define PS_PROJECT_GUID_HASH_OF_STRING_W
#define PS_PROJECT_GUID_HASH_OF_STRING_RA
#define PS_PROJECT_GUID_HASH_OF_STRING_RW
#define PS_ACTION_GUID_A
#define PS_ACTION_GUID_W
#define PS_ACTION_GUID_RA
#define PS_ACTION_GUID_RW
#define PS_BUILD_INFO_A
#define PS_BUILD_INFO_W
#define PS_BUILD_INFO_RA
#define PS_BUILD_INFO_RW
#define PS_VERSION_MAJOR
#define PS_VERSION_MINOR
#define PS_VERSION_BUILD
#define PS_VERSION_HOTFIX
#define PS_VERSION_A
#define PS_VERSION_W
#define PS_VERSION_RA
#define PS_VERSION_RW
#define PS_VERSION_MODULE_A
#define PS_VERSION_MODULE_W
#define PS_VERSION_MODULE_RA
#define PS_VERSION_MODULE_RW
#define PS_VERSION_PRODUCT_A
#define PS_VERSION_PRODUCT_W
#define PS_VERSION_PRODUCT_RA
#define PS_VERSION_PRODUCT_RW
#define PS_HOST_MODULE_NAME_A
#define PS_HOST_MODULE_NAME_W
#define PS_HOST_MODULE_NAME_RA
#define PS_HOST_MODULE_NAME_RW
#define PS_USER_INTERFACE_MODULE_NAME_A
#define PS_USER_INTERFACE_MODULE_NAME_W
#define PS_USER_INTERFACE_MODULE_NAME_RA
#define PS_USER_INTERFACE_MODULE_NAME_RW
#define PS_HELPER_MODULE_NAME_A
#define PS_HELPER_MODULE_NAME_W
#define PS_HELPER_MODULE_NAME_RA
#define PS_HELPER_MODULE_NAME_RW
#define SDK
#define PS_NO_BINDING_SUPPORTED
#define PS_BINDING_CHECK_LAST_RUN_TIME
#define PS_BINDING_CONTINUE_EXECUTION_AFTER_LICENSE_EXPIRATION
#define PS_BINDING_UPDATE_RUN_TIME_DATA_DURING_EXECUTION
#define PS_BINDING_CHECK_STARTUP_TIME
#define PS_SIMPLE_INITIALIZATION_SUPPORTED
#define PS_DEFAULT_INITIALIZATION_TYPE
#define PS_DRIVER_NAME_A
#define PS_DRIVER_NAME_W
#define PS_DRIVER_NAME_RA
#define PS_DRIVER_NAME_RW
#define PS_DRIVER_MODULE_NAME_A
#define PS_DRIVER_MODULE_NAME_W
#define PS_DRIVER_MODULE_NAME_RA
#define PS_DRIVER_MODULE_NAME_RW
#define PS_DRIVER_FRIENDLY_NAME_A
#define PS_DRIVER_FRIENDLY_NAME_W
#define PS_DRIVER_FRIENDLY_NAME_RA
#define PS_DRIVER_FRIENDLY_NAME_RW
#define PS_DRIVER_UNIQUE_FRIENDLY_NAME_A
#define PS_DRIVER_UNIQUE_FRIENDLY_NAME_W
#define PS_DRIVER_UNIQUE_FRIENDLY_NAME_RA
#define PS_DRIVER_UNIQUE_FRIENDLY_NAME_RW
#define PS_DRIVER_DEBUG_OUTPUT_PREFIX_A
#define PS_DRIVER_DEBUG_OUTPUT_PREFIX_W
#define PS_DRIVER_DEBUG_OUTPUT_PREFIX_RA
#define PS_DRIVER_DEBUG_OUTPUT_PREFIX_RW
#define PS_DRIVER_FS_NAME_A
#define PS_DRIVER_FS_NAME_W
#define PS_DRIVER_FS_NAME_RA
#define PS_DRIVER_FS_NAME_RW
#define PS_DRIVER_FS_MODULE_NAME_A
#define PS_DRIVER_FS_MODULE_NAME_W
#define PS_DRIVER_FS_MODULE_NAME_RA
#define PS_DRIVER_FS_MODULE_NAME_RW
#define PS_DRIVER_FS_FRIENDLY_NAME_A
#define PS_DRIVER_FS_FRIENDLY_NAME_W
#define PS_DRIVER_FS_FRIENDLY_NAME_RA
#define PS_DRIVER_FS_FRIENDLY_NAME_RW
#define PS_DRIVER_FS_UNIQUE_FRIENDLY_NAME_A
#define PS_DRIVER_FS_UNIQUE_FRIENDLY_NAME_W
#define PS_DRIVER_FS_UNIQUE_FRIENDLY_NAME_RA
#define PS_DRIVER_FS_UNIQUE_FRIENDLY_NAME_RW
#define PS_DRIVER_FS_DEBUG_OUTPUT_PREFIX_A
#define PS_DRIVER_FS_DEBUG_OUTPUT_PREFIX_W
#define PS_DRIVER_FS_DEBUG_OUTPUT_PREFIX_RA
#define PS_DRIVER_FS_DEBUG_OUTPUT_PREFIX_RW
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_NAME_A
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_NAME_W
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_NAME_RA
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_NAME_RW
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_MODULE_NAME_A
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_MODULE_NAME_W
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_MODULE_NAME_RA
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_MODULE_NAME_RW
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_FRIENDLY_NAME_A
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_FRIENDLY_NAME_W
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_FRIENDLY_NAME_RA
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_FRIENDLY_NAME_RW
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_UNIQUE_FRIENDLY_NAME_A
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_UNIQUE_FRIENDLY_NAME_W
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_UNIQUE_FRIENDLY_NAME_RA
#define PS_DRIVER_AUTO_REMOVAL_SERVICE_UNIQUE_FRIENDLY_NAME_RW
#define PS_DRIVER_UPDATE_HOST_A
#define PS_DRIVER_UPDATE_HOST_W
#define PS_DRIVER_UPDATE_HOST_RA
#define PS_DRIVER_UPDATE_HOST_RW
#define PS_DRIVER_UPDATE_PORT_A
#define PS_DRIVER_UPDATE_PORT_W
#define PS_DRIVER_UPDATE_PORT_RA
#define PS_DRIVER_UPDATE_PORT_RW
#define PS_DRIVER_UPDATE_PATH_A
#define PS_DRIVER_UPDATE_PATH_W
#define PS_DRIVER_UPDATE_PATH_RA
#define PS_DRIVER_UPDATE_PATH_RW
#define OPTION_X8632_SUPPORT
#define PS_TARGET_PLATFORM_X8632
#define USER_KEY_REGISTRY_HKEY
#define USER_KEY_REGISTRY_PATH_A
#define USER_KEY_REGISTRY_PATH_W
#define USER_KEY_REGISTRY_PATH_RA
#define USER_KEY_REGISTRY_PATH_RW
#define RELEASE_TIME
#define PS_BINDING_NONE_NONCOMMERCIAL
#define PS_BINDING_NONE_NONCOMMERCIAL_LIFETIME
#define PS_NAG_SCREEN_HARDWARE_LIFE_TIME
#define PS_NAG_SCREEN_HARDWARE_NUMBER_OF_RUNS
#define PS_NAG_SCREEN_HARDWARE_EXECUTION_TIME
#define PS_COMPANY_NAME_A
#define PS_COMPANY_NAME_W
#define PS_COMPANY_NAME_RA
#define PS_COMPANY_NAME_RW
#define PS_PRODUCT_NAME_A
#define PS_PRODUCT_NAME_W
#define PS_PRODUCT_NAME_RA
#define PS_PRODUCT_NAME_RW
#define PS_COPYRIGHT_A
#define PS_COPYRIGHT_W
#define PS_COPYRIGHT_RA
#define PS_COPYRIGHT_RW
#define TRADE_NAME_A
#define TRADE_NAME_W
#define TRADE_NAME_RA
#define TRADE_NAME_RW
#define PS_GUI_SHOW_BUY_BUTTON
#define PS_SHOW_DEACTIVATION_HYPERLINK
#define PS_SHOW_PROGRESS_BAR
#define OPTION_DRVINSTALL_QUESTION
#define PS_DISPLAY_DRIVERS_FAQ
#define OPTION_GUI_USE_SHIFT_KEY_FOR_KEY_ENTERING
#define OPTION_GUI_USE_CONTROL_KEY_FOR_KEY_ENTERING
#define OPTION_COLLECT_SYSTEM_INFORMATION
#define PS_USER_CAN_SELECT_LANGUAGE
#define PS_SHOW_HELP
#define PS_BUILD_TYPE
#define PS_BUILD_TYPE_SPECIAL
#define PS_BUILD_TYPE_NAME_A
#define PS_BUILD_TYPE_NAME_W
#define PS_BUILD_TYPE_NAME_RA
#define PS_BUILD_TYPE_NAME_RW
#define OPTION_CHECK_PROTECTION_LIBRARY_HEADER
#define OPTION_DETECT_PC_EMULATORS
#define OPTION_RESTRICT_PROCESS_OWNERS
#define OPTION_USE_ERROR_STACK_SIGNATURE
#define PS_SUPPORT_CRYPTED_TRAFFIC
#define PS_APPLICATION_EVENT_LOG_NAME_A
#define PS_APPLICATION_EVENT_LOG_NAME_W
#define PS_APPLICATION_EVENT_LOG_NAME_RA
#define PS_APPLICATION_EVENT_LOG_NAME_RW
#define PS_PROTECTED_MODULES
#define PS_PROTECTION_LIBRARY_A
#define PS_PROTECTION_LIBRARY_W
#define PS_PROTECTION_LIBRARY_RA
#define PS_PROTECTION_LIBRARY_RW
#define PS_SET_FOREGROUND_WINDOW_UNDER_VISTA
#define OPTION_ALLOW_SYSTEM_DEBUGGERS
#define OPTION_ALLOW_USER_DEBUGGERS
#define MEMORY_MANAGER_RANDOMIZATION
#define PS_BUILD_FULL_PROJECT
//
//	PsaApi.cs
//
//	File description:
//		File with public API functions. These functions can be used in
//      initialization module(???) as well as in protected application.
//

// Protected api
using System;
using System.Text;
using System.Runtime.InteropServices;

namespace ProtectionApi
{
	class PsaApi
	{
		[DllImport( "kernel32.dll" )]
		static extern IntPtr LoadLibrary( string fileName );
		static PsaApi()
		{
			IntPtr result = LoadLibrary( "protect.dll" );
		}
		//
		//	Description:
		//		Uninitialize protection core resources before unloading of protect.dll
		//		or before exit.
		//		The protection core can create threads for periodical checking of
		//		license expiration etc. If protect.dll will be unloaded using
		//		FreeLibrary( someProtectedDllHandle ) these threads will be	stopped
		//		by operating system and resources that are allocated in these threads
		//		will not be freed. It can lead to resource leaks if	the protected .DLL
		//		is loaded and unloaded many times.
		//		If you protect only .EXE files or there are no multiple
		//		loading/unloading of protected .DLL files the call to this function
		//		is not mandatory.
		//
		//	Output:
		//		Return value - PSC_STATUS_SUCCESS or error code
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_Uninitialize();

#if PS_USE_LICENSES

		//
		//	Description:
		//		Get registry path and base handle for license.
		//
		//	Input:
		//		pathBuffer					- buffer for path
		//		pathBufferSizeInWideChars	- buffer size
		//		registryBaseHandle			- buffer for base handle
		//
		//	Output:
		//		Return value				- PSC_STATUS_SUCCESS or error code
		//			(PSC_STATUS_BUFFER_TOO_SMALL if buffer is too small)
		//		*pathBuffer					- path (Unicode zero-terminated string)
		//		*pathBufferSizeInWideChars	- used buffer size (or required buffer
		//			size is return value is PSC_STATUS_BUFFER_TOO_SMALL)
		//		*registryBaseHandle			- buffer for base handle
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_GetLicenseStoragePath(
			[Out, MarshalAs( UnmanagedType.LPWStr )] StringBuilder pathBuffer,
			ref uint pathBufferSizeInWideChars,
			out IntPtr registryBaseHandle );

		enum LicVersion :uint
		{
		// License version (see PSA_GetLicenseInformation)
			LIC_VERSION_UNDEFINED = 0xFFFFFFFF,
			LIC_VERSION_0_DISC = 0,
			LIC_VERSION_1_HARDWARE = 1,
		}

		enum LicType:uint
		{
			// License types (see PSA_GetLicenseInformation)
			LIC_TYPE_UNDEFINED = 0xFFFFFFFF,
			LIC_TYPE_HARDWARE = 0,
			LIC_TYPE_HARDWARE_TRIAL = 1,
			LIC_TYPE_HARDWARE_RESCUE = 2,
			LIC_TYPE_HARDWARE_AUTOGENERATED_AFTER_DISC_CHECK = 3,
			LIC_TYPE_DISC = 4
		}
		//
		//	Description:
		//		Get special information for current license.
		//
		//	Input:
		//		version			- buffer for license version
		//		type			- buffer for license type
		//		nonCommercial	- buffer for non-commercial flag
		//
		//	Output:
		//		Return value	- PSC_STATUS_SUCCESS or error code
		//		*version		- license version
		//		*type			- license type
		//		*nonCommercial	- non-commercial flag
		//
		//	Registry keys for debugging:
		//		"LicenseVersion", "LicenseType", "IsNonCommercialLicense" of type
		//		REG_DWORD (initialized at loading of protect.dll).
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_GetLicenseInformation(
			out UInt32 version, out UInt32 type, [Out, MarshalAs(UnmanagedType.U1)]out Boolean nonCommercial );

#endif

		//
		//	Limitation of functionality
		//

#if PS_USE_LICENSES

		// Codes of independent features that can be granted by license
		enum PSA_GrantedFeature: uint
		{
			PSA_GrantedFeature0 = 0x00000001,
			PSA_GrantedFeature1 = 0x00000002,
			PSA_GrantedFeature2 = 0x00000004,
			PSA_GrantedFeature3 = 0x00000008,
			PSA_GrantedFeature4 = 0x00000010,
			PSA_GrantedFeature5 = 0x00000020,
			PSA_GrantedFeature6 = 0x00000040,
			PSA_GrantedFeature7 = 0x00000080,
			PSA_GrantedFeature8 = 0x00000100,
			PSA_GrantedFeature9 = 0x00000200,
			PSA_GrantedFeature10 = 0x00000400,
			PSA_GrantedFeature11 = 0x00000800,
			PSA_GrantedFeature12 = 0x00001000,
			PSA_GrantedFeature13 = 0x00002000,
			PSA_GrantedFeature14 = 0x00004000,
			PSA_GrantedFeature15 = 0x00008000,
			PSA_GrantedFeature16 = 0x00010000,
			PSA_GrantedFeature17 = 0x00020000,
			PSA_GrantedFeature18 = 0x00040000,
			PSA_GrantedFeature19 = 0x00080000,
			PSA_GrantedFeature20 = 0x00100000,
			PSA_GrantedFeature21 = 0x00200000,
			PSA_GrantedFeature22 = 0x00400000,
			PSA_GrantedFeature23 = 0x00800000,
			PSA_GrantedFeature24 = 0x01000000,
			PSA_GrantedFeature25 = 0x02000000,
			PSA_GrantedFeature26 = 0x04000000,
			PSA_GrantedFeature27 = 0x08000000,
			PSA_GrantedFeature28 = 0x10000000,
			PSA_GrantedFeature29 = 0x20000000,
			PSA_GrantedFeature30 = 0x40000000,
			PSA_GrantedFeature31 = 0x80000000
		}
		//
		//	Description:
		//		Get a set of features granted by license (bit mask).
		//		For example, this function can return the value	*features = 9,
		//		i.e. ( PSA_GrantedFeature0 | PSA_GrantedFeature3 ).
		//		This function returns *features = 0 for demo mode (if demo mode has
		//		been enabled).
		//
		//	Input:
		//		features		- buffer for feature set
		//
		//	Output:
		//		*features		- feature set
		//		Return value	- PSC_STATUS_SUCCESS or error code
		//
		//	Registry keys for debugging:
		//		"FeatureSetGrantedByLicense" of type REG_DWORD (initialized at
		//		loading of protect.dll).
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_GetFeaturesGrantedByLicense( out UInt32 features );

		//
		//	Description:
		//		Disable features granted by license for limitation of application
		//		functionality "on the fly" e.g. after expiration of license (only
		//		enabled features will be disabled, so, 0xFFFFFFFF is valid argument
		//		for disabling of all features).
		//
		//	Input:
		//		features		- buffer for feature set mask
		//
		//	Output:
		//		Return value	- PSC_STATUS_SUCCESS or error code
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_DisableFeaturesGrantedByLicense( UInt32 features );

		//
		//	Description:
		//		Check rights granted by license and display error dialog on error.
		//		This function works only in SDK mode. In normal protected application
		//		is does nothing.
		//
		//	Input:
		//		features		- features mask to check (the check succeed if
		//			at least one bit from the mask is set in current license)
		//
		//	Output:
		//		Return value	- PSC_STATUS_SUCCESS if the check succeeds or fails
		//			or error code on internal error
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_CheckFeaturesGrantedByLicense( UInt32 features );

#endif

		//
		//	Program start mode
		//

#if PS_USE_LICENSES

		//
		//	Description:
		//		Check if the application is running in demo mode.
		//
		//	Input:
		//		isDemoMode		- buffer for demo mode flag
		//
		//	Output:
		//		Return value	- PSC_STATUS_SUCCESS or error code
		//		*isDemoMode		- demo mode flag
		//
		//	Registry keys for debugging:
		//		"IsDemoMode" of type REG_DWORD (initialized at loading of protect.dll).
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_IsDemoMode( [Out, MarshalAs(UnmanagedType.U1)]out Boolean isDemoMode );

		//
		//	Description:
		//		Check if the application is running in trial mode.
		//
		//	Input:
		//		isTrialMode		- buffer for trial mode flag
		//
		//	Output:
		//		Return value	- PSC_STATUS_SUCCESS or error code
		//		*isTrialMode	- trial mode flag
		//
		//	Registry keys for debugging:
		//		"IsTrialMode" of type REG_DWORD (initialized at loading of protect.dll).
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_IsTrialMode( [Out, MarshalAs(UnmanagedType.U1)]out Boolean isTrialMode );

#endif

		//
		//	Expiration parameters of license
		//

#if PS_USE_LICENSES

		//
		//	Description:
		//		Check if the license is already expired.
		//
		//	Input:
		//		isLicenseExpired	- buffer for license expired flag
		//
		//	Output:
		//		Return value		- PSC_STATUS_SUCCESS or error code
		//		*isLicenseExpired	- license expired flag
		//		updateRunTimeData	- flag for updating of license usage history
		//
		//	Registry keys for debugging:
		//		"IsLicenseExpired" of type REG_DWORD (reinitialized at each call).
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_IsLicenseExpired(
			[Out, MarshalAs(UnmanagedType.U1)]out Boolean isLicenseExpired, [In, MarshalAs(UnmanagedType.U1)]Boolean updateRunTimeData );

		//
		//	Description:
		//		Get the time before expiration of license.
		//
		//	Input:
		//		timeToLicenseExpiration		- buffer for time
		//
		//	Output:
		//		Return value				- PSC_STATUS_SUCCESS or error code
		//		*timeToLicenseExpiration	- time before expiration of license in
		//			100 ns intervals (0 - license expired, ~0ui64 - undefined or
		//			infinite)
		//
		//	Registry keys for debugging:
		//		"TimeToLicenseExpiration" of type REG_BINARY and length 8 bytes
		//		(reinitialized at each call).
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_GetTimeToLicenseExpiration(
			out UInt64 timeToLicenseExpiration );

		//
		//	Description:
		//		Get date and time of license expiration.
		//
		//	Input:
		//		licenseExpirationDateTime	- buffer for date and time
		//
		//	Output:
		//		Return value				- PSC_STATUS_SUCCESS or error code
		//		*licenseExpirationDateTime	- date and time of license expiration in
		//			file time format, i.e. number of 100 ns intervals elapsed since
		//			January 1, 1601 (~0ui64 - undefined or infinite)
		//
		//	Registry keys for debugging:
		//		"LicenseExpirationDateTime" of type REG_BINARY and length 8 bytes
		//		(initialized at loading of protect.dll).
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_GetLicenseExpirationDateTime( out UInt64 licenseExpirationDateTime );

		//
		//	Description:
		//		Get life time limit of license (i.e. time before expiration of license
		//		from the moment of license creation, as assigned by e.g. activation
		//		key).
		//
		//	Input:
		//		licenseLifeTimeLimit	- buffer for life time limit
		//
		//	Output:
		//		Return value			- PSC_STATUS_SUCCESS or error code
		//		*licenseLifeTimeLimit	- life time limit in 100 ns intervals
		//			(~0ui64 - undefined or infinite).
		//
		//	Registry keys for debugging:
		//		"LicenseLifeTimeLimit" of type REG_BINARY and length 8 bytes
		//		(initialized at loading of protect.dll).
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_GetLicenseLifeTimeLimit( out UInt64 licenseLifeTimeLimit );

		//
		//	Description:
		//		Get remaining number of runs.
		//
		//	Input:
		//		remainingNumberOfRuns	- buffer for remaining number of runs
		//
		//	Output:
		//		Return value			- PSC_STATUS_SUCCESS or error code
		//		*remainingNumberOfRuns	- remaining number of runs (~0ui32 - undefined
		//			or infinite)
		//
		//	Registry keys for debugging:
		//		"RemainingNumberOfRuns" of type REG_DWORD (initialized at loading of
		//		protect.dll).
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_GetRemainingNumberOfRuns( out UInt32 remainingNumberOfRuns );

		//
		//	Description:
		//		Get limit for number of runs (i.e. total allowed number of runs, as
		//		assigned by e.g. activation key).
		//
		//	Input:
		//		remainingNumberOfRuns	- buffer for limit of number of runs
		//
		//	Output:
		//		Return value			- PSC_STATUS_SUCCESS or error code
		//		*remainingNumberOfRuns	- limit of number of runs (~0ui32 - undefined
		//			or infinite)
		//
		//	Registry keys for debugging:
		//		"LicenseNumberOfRunsLimit" of type REG_DWORD (initialized at loading of
		//		protect.dll).
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_GetLicenseNumberOfRunsLimit( out UInt32 licenseNumberOfRunsLimit );

		//
		//	Description:
		//		Get remaining execution time of application, calculated in the current
		//		moment.
		//
		//	Input:
		//		remainingExecutionTime	- buffer for remaining execution time
		//
		//	Output:
		//		Return value			- PSC_STATUS_SUCCESS or error code
		//		*remainingExecutionTime	- remaining execution time in 100 ns intervals
		//			(0 - license expired, ~0ui64 - undefined or infinite)
		//
		//	Registry keys for debugging:
		//		"RemainingExecutionTime" of type REG_BINARY and length 8 bytes
		//		(reinitialized at each call).
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_GetRemainingExecutionTime( out UInt64 remainingExecutionTime );

		//
		//	Description:
		//		Get remaining execution time of application, calculated in the moment
		//		of start of application.
		//
		//	Input:
		//		remainingExecutinTimeAtStart	- buffer for remaining execution time
		//
		//	Output:
		//		Return value					- PSC_STATUS_SUCCESS or error code
		//		*remainingExecutinTimeAtStart	- remaining execution time in 100 ns
		//			intervals (0 - license expired, ~0ui64 - undefined or infinite)
		//
		//	Registry keys for debugging:
		//		"RemainingExecutionTimeAtStart" of type REG_BINARY and length 8 bytes
		//		(initialized at loading of protect.dll).
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_GetRemainingExecutionTimeAtStart( out UInt64 remainingExecutinTimeAtStart );

		//
		//	Description:
		//		Get limit for execution time of application(i.e. total allowed
		//		execution time assigned by e.g. activation key).
		//
		//	Input:
		//		licenseExecutionTimeLimit	- buffer for limit of execution time
		//
		//	Output:
		//		Return value				- PSC_STATUS_SUCCESS or error code
		//		*licenseExecutionTimeLimit	- limit of execution time in 100 ns
		//			intervals (~0ui64 - undefined or infinite)
		//
		//	Registry keys for debugging:
		//		"LicenseExecutionTimeLimit" of type REG_BINARY and length 8 bytes
		//		(initialized at loading of protect.dll).
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_GetLicenseExecutionTimeLimit( out UInt64 licenseExecutionTimeLimit );

#endif

		//
		//	User-defined data in the key
		//

#if PS_USE_LICENSES

		//
		//	Description:
		//		Get user-defined field.
		//
		//	Input:
		//		userDefinedField	- buffer for user-defined field
		//
		//	Output:
		//		Return value		- PSC_STATUS_SUCCESS or error code
		//		*userDefinedField	- user-defined field (0xFFFF if undefined)
		//
		//	Registry keys for debugging:
		//		"UserDefinedField16Bits" of type REG_DWORD (initialized at loading
		//		of protect.dll).
		//
		[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
		public static extern UInt32 PSA_GetUserDefinedField16Bits( out UInt16 userDefinedField );

#endif

		//
		//	Specific functions for disc binding
		//

#if BINDING_DISC

	//	Description:
	//		Get the label of disc with that the check was passed.
	//
	//	Input:
	//		labelBuffer					- buffer for disc label
	//		labelBufferSizeInWideChars	- buffer size
	//
	//	Output:
	//		Return value				- PSC_STATUS_SUCCESS or error code
	//			(PSC_STATUS_BUFFER_TOO_SMALL if buffer is too small)
	//		*labelBuffer				- label (Unicode zero-terminated string)
	//		*labelBufferSizeInWideChars	- used buffer size (or required buffer
	//			size is return value is PSC_STATUS_BUFFER_TOO_SMALL)
	//
	//	Registry keys for debugging:
	//		"DiscLabel" of type REG_SZ (initialized at loading of protect.dll).
	//
	[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
	public static extern UInt32 PSA_GetDiscLabel(
		[Out, MarshalAs( UnmanagedType.LPWStr )] StringBuilder labelBuffer,
		ref int labelBufferSizeInWideChars );

#endif

		// 
		// Specific functions for external binding
		// 

#if PS_EXTERNAL_BASED_INITIALIZATION_SUPPORTED

	//	Description:
	//		Set external binding check success flag. By default flag 
	//		is cleared.
	//
	//	Output:
	//		Return value				- PSC_STATUS_SUCCESS
	//
	[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
	public static extern UInt32 PSA_ExternalBindingCheckSetSucceedFlag();

	//	Description:
	//		Clear external binding check success flag. By default flag 
	//		is cleared.
	//
	//	Output:
	//		Return value				- PSC_STATUS_SUCCESS
	//
	[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
	public static extern UInt32 PSA_ExternalBindingCheckSetFailedFlag();

#endif
	}
	
#if PS_SUPPORT_FILE_CHECK_API
//  Description:
//		Returns result of loaded files checks
//  Input:
//		fileCheckResultOk 			- output variable
//									  set to true if all of protected files loaded not corrupted
//									  set to false if hash check for one or more files failed 
//	Output:
//		Return value				- PSC_STATUS_SUCCESS
	[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
	public static UInt32 PSA_GetCheckFilesHashResult( out bool fileCheckResultOk );
#endif

#if PS_SUPPORT_MEMORY_CHECK_API
//  Description:
//		Checks read only memory regions of protected modules, calculates hash and 
//		compare to hash value stored in protection library
//  Input:
//		memCheckResultOk 			- output variable
//									  set to true if read only memory for all protected modules remains unchanged
//									  set to false if memory changed for one or more modules
//	Output:
//		Return value				- PSC_STATUS_SUCCESS
	[DllImport( "protect.dll", CallingConvention = CallingConvention.StdCall )]
	public static UInt32 PSA_CheckProtectedModulesReadOnlyMem( out bool memCheckResultOk );
	
#endif	
	
}

class PsUInt1
{

	public override bool Equals( object obj )
	{
		if( obj == null ) return false;
		if( this.GetType() != obj.GetType() ) return false;
		if( m_value != ( (PsUInt1)obj ).m_value ) return false;
		return true;
	}

	public override int GetHashCode()
	{
		return (int)m_value;
	}
// Internal functions for protected class
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1ConvertEX( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1AssignXN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1AddEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1AddEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1SubEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1SubEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1SubNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1MulEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1MulEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1DivEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1DivEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1DivNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1RemEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1RemEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1RemNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1ShlEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1ShlEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1ShlNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1ShrEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1ShrEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1ShrNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1AndEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1AndEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1OrEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1OrEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1XorEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1XorEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1CeqEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1CltEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1CltEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1CltNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1CgtEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1CgtEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt1CgtNE( UInt32 value1, UInt32 value2 );
	private	UInt32 m_value;

	public PsUInt1()
	{
	}

	public PsUInt1( UInt32 value )
	{
		m_value = PSA_PsUInt1AssignXN( m_value, value );
	}

	public PsUInt1( PsUInt1 value )
	{
		m_value = value.m_value;
	}

	public static implicit operator UInt32( PsUInt1 value)
	{
		return PSA_PsUInt1ConvertEX( value.m_value, 1 );
	}

	public UInt32 Value()
	{
		return PSA_PsUInt1ConvertEX( m_value, 1 );
	}

	public static PsUInt1 operator + ( PsUInt1 src )
	{
		return src;
	}

	public static PsUInt1 operator - ( PsUInt1 src )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1SubNE( 0, src.m_value );
		return temp;
	}

	public static PsUInt1 operator ~ ( PsUInt1 src )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1XorEN( src.m_value, ~0u );
		return temp;
	}

	public static PsUInt1 operator ++ ( PsUInt1 src )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1AddEN( src.m_value, 1 );
		return temp;
	}
	public static PsUInt1 operator -- ( PsUInt1 src )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1SubEN( src.m_value, 1 );
		return temp;
	}

	public static PsUInt1 operator + ( PsUInt1 value1, PsUInt1 value2 )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1AddEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt1 operator + ( PsUInt1 value1, UInt32 value2 )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1AddEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt1 operator + ( UInt32 value1, PsUInt1 value2  )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1AddEN( value2.m_value, value1 );
		return temp;
	}

	public static PsUInt1 operator - ( PsUInt1 value1, PsUInt1 value2 )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1SubEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt1 operator - ( PsUInt1 value1, UInt32 value2 )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1SubEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt1 operator - ( UInt32 value1, PsUInt1 value2  )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1SubNE( value1, value2.m_value );
		return temp;
	}

	public static PsUInt1 operator * ( PsUInt1 value1, PsUInt1 value2 )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1MulEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt1 operator * ( PsUInt1 value1, UInt32 value2 )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1MulEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt1 operator * ( UInt32 value1, PsUInt1 value2  )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1MulEN( value2.m_value, value1 );
		return temp;
	}

	public static PsUInt1 operator / ( PsUInt1 value1, PsUInt1 value2 )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1DivEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt1 operator / ( PsUInt1 value1, UInt32 value2 )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1DivEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt1 operator / ( UInt32 value1, PsUInt1 value2  )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1DivNE( value1, value2.m_value );
		return temp;
	}

	public static PsUInt1 operator % ( PsUInt1 value1, PsUInt1 value2 )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1RemEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt1 operator % ( PsUInt1 value1, UInt32 value2 )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1RemEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt1 operator % ( UInt32 value1, PsUInt1 value2  )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1RemNE( value1, value2.m_value );
		return temp;
	}


	public static PsUInt1 operator << ( PsUInt1 value1, int shift )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1ShlEN( value1.m_value, (UInt32)shift );
		return temp;
	}


	public static PsUInt1 operator >> ( PsUInt1 value1, int shift )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1ShrEN( value1.m_value, (UInt32)shift );
		return temp;
	}

	public static PsUInt1 operator & ( PsUInt1 value1, PsUInt1 value2 )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1AndEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt1 operator & ( PsUInt1 value1, UInt32 value2 )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1AndEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt1 operator & ( UInt32 value1, PsUInt1 value2  )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1AndEN( value2.m_value, value1 );
		return temp;
	}

	public static PsUInt1 operator | ( PsUInt1 value1, PsUInt1 value2 )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1OrEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt1 operator | ( PsUInt1 value1, UInt32 value2 )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1OrEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt1 operator | ( UInt32 value1, PsUInt1 value2  )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1OrEN( value2.m_value, value1 );
		return temp;
	}

	public static PsUInt1 operator ^ ( PsUInt1 value1, PsUInt1 value2 )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1XorEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt1 operator ^ ( PsUInt1 value1, UInt32 value2 )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1XorEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt1 operator ^ ( UInt32 value1, PsUInt1 value2  )
	{
		PsUInt1 temp = new PsUInt1();
		temp.m_value = PSA_PsUInt1XorEN( value2.m_value, value1 );
		return temp;
	}

	public static bool operator == ( PsUInt1 value1, PsUInt1 value2 )
	{
		bool temp;
		temp = false != ( value1.m_value == value2.m_value );
		return temp;
	}

	public static bool operator == ( PsUInt1 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt1CeqEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator == ( UInt32 value1, PsUInt1 value2  )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt1CeqEN( value2.m_value, value1 );
		return temp;
	}

	public static bool operator != ( PsUInt1 value1, PsUInt1 value2 )
	{
		bool temp;
		temp = false != ( value1.m_value != value2.m_value );
		return temp;
	}

	public static bool operator != ( PsUInt1 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt1CeqEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator != ( UInt32 value1, PsUInt1 value2  )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt1CeqEN( value2.m_value, value1 );
		return temp;
	}

	public static bool operator < ( PsUInt1 value1, PsUInt1 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt1CltEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static bool operator < ( PsUInt1 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt1CltEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator < ( UInt32 value1, PsUInt1 value2  )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt1CltNE( value1, value2.m_value );
		return temp;
	}

	public static bool operator <= ( PsUInt1 value1, PsUInt1 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt1CgtEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static bool operator <= ( PsUInt1 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt1CgtEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator <= ( UInt32 value1, PsUInt1 value2  )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt1CgtNE( value1, value2.m_value );
		return temp;
	}

	public static bool operator > ( PsUInt1 value1, PsUInt1 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt1CgtEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static bool operator > ( PsUInt1 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt1CgtEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator > ( UInt32 value1, PsUInt1 value2  )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt1CgtNE( value1, value2.m_value );
		return temp;
	}

	public static bool operator >= ( PsUInt1 value1, PsUInt1 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt1CltEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static bool operator >= ( PsUInt1 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt1CltEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator >= ( UInt32 value1, PsUInt1 value2  )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt1CltNE( value1, value2.m_value );
		return temp;
	}

}


class PsUInt2
{

	public override bool Equals( object obj )
	{
		if( obj == null ) return false;
		if( this.GetType() != obj.GetType() ) return false;
		if( m_value != ( (PsUInt2)obj ).m_value ) return false;
		return true;
	}

	public override int GetHashCode()
	{
		return (int)m_value;
	}
// Internal functions for protected class
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2ConvertEX( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2AssignXN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2AddEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2AddEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2SubEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2SubEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2SubNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2MulEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2MulEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2DivEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2DivEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2DivNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2RemEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2RemEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2RemNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2ShlEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2ShlEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2ShlNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2ShrEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2ShrEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2ShrNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2AndEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2AndEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2OrEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2OrEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2XorEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2XorEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2CeqEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2CltEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2CltEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2CltNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2CgtEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2CgtEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt2CgtNE( UInt32 value1, UInt32 value2 );
	private	UInt32 m_value;

	public PsUInt2()
	{
	}

	public PsUInt2( UInt32 value )
	{
		m_value = PSA_PsUInt2AssignXN( m_value, value );
	}

	public PsUInt2( PsUInt2 value )
	{
		m_value = value.m_value;
	}

	public static implicit operator UInt32( PsUInt2 value)
	{
		return PSA_PsUInt2ConvertEX( value.m_value, 1 );
	}

	public UInt32 Value()
	{
		return PSA_PsUInt2ConvertEX( m_value, 1 );
	}

	public static PsUInt2 operator + ( PsUInt2 src )
	{
		return src;
	}

	public static PsUInt2 operator - ( PsUInt2 src )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2SubNE( 0, src.m_value );
		return temp;
	}

	public static PsUInt2 operator ~ ( PsUInt2 src )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2XorEN( src.m_value, ~0u );
		return temp;
	}

	public static PsUInt2 operator ++ ( PsUInt2 src )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2AddEN( src.m_value, 1 );
		return temp;
	}
	public static PsUInt2 operator -- ( PsUInt2 src )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2SubEN( src.m_value, 1 );
		return temp;
	}

	public static PsUInt2 operator + ( PsUInt2 value1, PsUInt2 value2 )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2AddEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt2 operator + ( PsUInt2 value1, UInt32 value2 )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2AddEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt2 operator + ( UInt32 value1, PsUInt2 value2  )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2AddEN( value2.m_value, value1 );
		return temp;
	}

	public static PsUInt2 operator - ( PsUInt2 value1, PsUInt2 value2 )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2SubEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt2 operator - ( PsUInt2 value1, UInt32 value2 )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2SubEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt2 operator - ( UInt32 value1, PsUInt2 value2  )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2SubNE( value1, value2.m_value );
		return temp;
	}

	public static PsUInt2 operator * ( PsUInt2 value1, PsUInt2 value2 )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2MulEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt2 operator * ( PsUInt2 value1, UInt32 value2 )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2MulEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt2 operator * ( UInt32 value1, PsUInt2 value2  )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2MulEN( value2.m_value, value1 );
		return temp;
	}

	public static PsUInt2 operator / ( PsUInt2 value1, PsUInt2 value2 )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2DivEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt2 operator / ( PsUInt2 value1, UInt32 value2 )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2DivEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt2 operator / ( UInt32 value1, PsUInt2 value2  )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2DivNE( value1, value2.m_value );
		return temp;
	}

	public static PsUInt2 operator % ( PsUInt2 value1, PsUInt2 value2 )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2RemEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt2 operator % ( PsUInt2 value1, UInt32 value2 )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2RemEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt2 operator % ( UInt32 value1, PsUInt2 value2  )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2RemNE( value1, value2.m_value );
		return temp;
	}


	public static PsUInt2 operator << ( PsUInt2 value1, int shift )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2ShlEN( value1.m_value, (UInt32)shift );
		return temp;
	}


	public static PsUInt2 operator >> ( PsUInt2 value1, int shift )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2ShrEN( value1.m_value, (UInt32)shift );
		return temp;
	}

	public static PsUInt2 operator & ( PsUInt2 value1, PsUInt2 value2 )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2AndEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt2 operator & ( PsUInt2 value1, UInt32 value2 )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2AndEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt2 operator & ( UInt32 value1, PsUInt2 value2  )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2AndEN( value2.m_value, value1 );
		return temp;
	}

	public static PsUInt2 operator | ( PsUInt2 value1, PsUInt2 value2 )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2OrEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt2 operator | ( PsUInt2 value1, UInt32 value2 )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2OrEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt2 operator | ( UInt32 value1, PsUInt2 value2  )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2OrEN( value2.m_value, value1 );
		return temp;
	}

	public static PsUInt2 operator ^ ( PsUInt2 value1, PsUInt2 value2 )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2XorEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt2 operator ^ ( PsUInt2 value1, UInt32 value2 )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2XorEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt2 operator ^ ( UInt32 value1, PsUInt2 value2  )
	{
		PsUInt2 temp = new PsUInt2();
		temp.m_value = PSA_PsUInt2XorEN( value2.m_value, value1 );
		return temp;
	}

	public static bool operator == ( PsUInt2 value1, PsUInt2 value2 )
	{
		bool temp;
		temp = false != ( value1.m_value == value2.m_value );
		return temp;
	}

	public static bool operator == ( PsUInt2 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt2CeqEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator == ( UInt32 value1, PsUInt2 value2  )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt2CeqEN( value2.m_value, value1 );
		return temp;
	}

	public static bool operator != ( PsUInt2 value1, PsUInt2 value2 )
	{
		bool temp;
		temp = false != ( value1.m_value != value2.m_value );
		return temp;
	}

	public static bool operator != ( PsUInt2 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt2CeqEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator != ( UInt32 value1, PsUInt2 value2  )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt2CeqEN( value2.m_value, value1 );
		return temp;
	}

	public static bool operator < ( PsUInt2 value1, PsUInt2 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt2CltEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static bool operator < ( PsUInt2 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt2CltEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator < ( UInt32 value1, PsUInt2 value2  )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt2CltNE( value1, value2.m_value );
		return temp;
	}

	public static bool operator <= ( PsUInt2 value1, PsUInt2 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt2CgtEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static bool operator <= ( PsUInt2 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt2CgtEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator <= ( UInt32 value1, PsUInt2 value2  )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt2CgtNE( value1, value2.m_value );
		return temp;
	}

	public static bool operator > ( PsUInt2 value1, PsUInt2 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt2CgtEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static bool operator > ( PsUInt2 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt2CgtEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator > ( UInt32 value1, PsUInt2 value2  )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt2CgtNE( value1, value2.m_value );
		return temp;
	}

	public static bool operator >= ( PsUInt2 value1, PsUInt2 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt2CltEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static bool operator >= ( PsUInt2 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt2CltEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator >= ( UInt32 value1, PsUInt2 value2  )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt2CltNE( value1, value2.m_value );
		return temp;
	}

}


class PsUInt3
{

	public override bool Equals( object obj )
	{
		if( obj == null ) return false;
		if( this.GetType() != obj.GetType() ) return false;
		if( m_value != ( (PsUInt3)obj ).m_value ) return false;
		return true;
	}

	public override int GetHashCode()
	{
		return (int)m_value;
	}
// Internal functions for protected class
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3ConvertEX( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3AssignXN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3AddEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3AddEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3SubEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3SubEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3SubNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3MulEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3MulEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3DivEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3DivEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3DivNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3RemEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3RemEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3RemNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3ShlEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3ShlEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3ShlNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3ShrEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3ShrEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3ShrNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3AndEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3AndEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3OrEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3OrEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3XorEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3XorEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3CeqEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3CltEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3CltEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3CltNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3CgtEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3CgtEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt3CgtNE( UInt32 value1, UInt32 value2 );
	private	UInt32 m_value;

	public PsUInt3()
	{
	}

	public PsUInt3( UInt32 value )
	{
		m_value = PSA_PsUInt3AssignXN( m_value, value );
	}

	public PsUInt3( PsUInt3 value )
	{
		m_value = value.m_value;
	}

	public static implicit operator UInt32( PsUInt3 value)
	{
		return PSA_PsUInt3ConvertEX( value.m_value, 1 );
	}

	public UInt32 Value()
	{
		return PSA_PsUInt3ConvertEX( m_value, 1 );
	}

	public static PsUInt3 operator + ( PsUInt3 src )
	{
		return src;
	}

	public static PsUInt3 operator - ( PsUInt3 src )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3SubNE( 0, src.m_value );
		return temp;
	}

	public static PsUInt3 operator ~ ( PsUInt3 src )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3XorEN( src.m_value, ~0u );
		return temp;
	}

	public static PsUInt3 operator ++ ( PsUInt3 src )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3AddEN( src.m_value, 1 );
		return temp;
	}
	public static PsUInt3 operator -- ( PsUInt3 src )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3SubEN( src.m_value, 1 );
		return temp;
	}

	public static PsUInt3 operator + ( PsUInt3 value1, PsUInt3 value2 )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3AddEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt3 operator + ( PsUInt3 value1, UInt32 value2 )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3AddEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt3 operator + ( UInt32 value1, PsUInt3 value2  )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3AddEN( value2.m_value, value1 );
		return temp;
	}

	public static PsUInt3 operator - ( PsUInt3 value1, PsUInt3 value2 )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3SubEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt3 operator - ( PsUInt3 value1, UInt32 value2 )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3SubEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt3 operator - ( UInt32 value1, PsUInt3 value2  )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3SubNE( value1, value2.m_value );
		return temp;
	}

	public static PsUInt3 operator * ( PsUInt3 value1, PsUInt3 value2 )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3MulEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt3 operator * ( PsUInt3 value1, UInt32 value2 )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3MulEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt3 operator * ( UInt32 value1, PsUInt3 value2  )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3MulEN( value2.m_value, value1 );
		return temp;
	}

	public static PsUInt3 operator / ( PsUInt3 value1, PsUInt3 value2 )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3DivEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt3 operator / ( PsUInt3 value1, UInt32 value2 )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3DivEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt3 operator / ( UInt32 value1, PsUInt3 value2  )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3DivNE( value1, value2.m_value );
		return temp;
	}

	public static PsUInt3 operator % ( PsUInt3 value1, PsUInt3 value2 )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3RemEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt3 operator % ( PsUInt3 value1, UInt32 value2 )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3RemEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt3 operator % ( UInt32 value1, PsUInt3 value2  )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3RemNE( value1, value2.m_value );
		return temp;
	}


	public static PsUInt3 operator << ( PsUInt3 value1, int shift )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3ShlEN( value1.m_value, (UInt32)shift );
		return temp;
	}


	public static PsUInt3 operator >> ( PsUInt3 value1, int shift )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3ShrEN( value1.m_value, (UInt32)shift );
		return temp;
	}

	public static PsUInt3 operator & ( PsUInt3 value1, PsUInt3 value2 )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3AndEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt3 operator & ( PsUInt3 value1, UInt32 value2 )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3AndEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt3 operator & ( UInt32 value1, PsUInt3 value2  )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3AndEN( value2.m_value, value1 );
		return temp;
	}

	public static PsUInt3 operator | ( PsUInt3 value1, PsUInt3 value2 )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3OrEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt3 operator | ( PsUInt3 value1, UInt32 value2 )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3OrEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt3 operator | ( UInt32 value1, PsUInt3 value2  )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3OrEN( value2.m_value, value1 );
		return temp;
	}

	public static PsUInt3 operator ^ ( PsUInt3 value1, PsUInt3 value2 )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3XorEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt3 operator ^ ( PsUInt3 value1, UInt32 value2 )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3XorEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt3 operator ^ ( UInt32 value1, PsUInt3 value2  )
	{
		PsUInt3 temp = new PsUInt3();
		temp.m_value = PSA_PsUInt3XorEN( value2.m_value, value1 );
		return temp;
	}

	public static bool operator == ( PsUInt3 value1, PsUInt3 value2 )
	{
		bool temp;
		temp = false != ( value1.m_value == value2.m_value );
		return temp;
	}

	public static bool operator == ( PsUInt3 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt3CeqEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator == ( UInt32 value1, PsUInt3 value2  )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt3CeqEN( value2.m_value, value1 );
		return temp;
	}

	public static bool operator != ( PsUInt3 value1, PsUInt3 value2 )
	{
		bool temp;
		temp = false != ( value1.m_value != value2.m_value );
		return temp;
	}

	public static bool operator != ( PsUInt3 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt3CeqEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator != ( UInt32 value1, PsUInt3 value2  )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt3CeqEN( value2.m_value, value1 );
		return temp;
	}

	public static bool operator < ( PsUInt3 value1, PsUInt3 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt3CltEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static bool operator < ( PsUInt3 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt3CltEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator < ( UInt32 value1, PsUInt3 value2  )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt3CltNE( value1, value2.m_value );
		return temp;
	}

	public static bool operator <= ( PsUInt3 value1, PsUInt3 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt3CgtEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static bool operator <= ( PsUInt3 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt3CgtEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator <= ( UInt32 value1, PsUInt3 value2  )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt3CgtNE( value1, value2.m_value );
		return temp;
	}

	public static bool operator > ( PsUInt3 value1, PsUInt3 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt3CgtEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static bool operator > ( PsUInt3 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt3CgtEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator > ( UInt32 value1, PsUInt3 value2  )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt3CgtNE( value1, value2.m_value );
		return temp;
	}

	public static bool operator >= ( PsUInt3 value1, PsUInt3 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt3CltEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static bool operator >= ( PsUInt3 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt3CltEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator >= ( UInt32 value1, PsUInt3 value2  )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt3CltNE( value1, value2.m_value );
		return temp;
	}

}


class PsUInt4
{

	public override bool Equals( object obj )
	{
		if( obj == null ) return false;
		if( this.GetType() != obj.GetType() ) return false;
		if( m_value != ( (PsUInt4)obj ).m_value ) return false;
		return true;
	}

	public override int GetHashCode()
	{
		return (int)m_value;
	}
// Internal functions for protected class
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4ConvertEX( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4AssignXN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4AddEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4AddEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4SubEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4SubEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4SubNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4MulEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4MulEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4DivEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4DivEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4DivNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4RemEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4RemEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4RemNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4ShlEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4ShlEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4ShlNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4ShrEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4ShrEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4ShrNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4AndEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4AndEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4OrEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4OrEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4XorEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4XorEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4CeqEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4CltEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4CltEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4CltNE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4CgtEE( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4CgtEN( UInt32 value1, UInt32 value2 );
[DllImport( "protect.dll", CallingConvention=CallingConvention.StdCall )]
public static extern UInt32 PSA_PsUInt4CgtNE( UInt32 value1, UInt32 value2 );
	private	UInt32 m_value;

	public PsUInt4()
	{
	}

	public PsUInt4( UInt32 value )
	{
		m_value = PSA_PsUInt4AssignXN( m_value, value );
	}

	public PsUInt4( PsUInt4 value )
	{
		m_value = value.m_value;
	}

	public static implicit operator UInt32( PsUInt4 value)
	{
		return PSA_PsUInt4ConvertEX( value.m_value, 1 );
	}

	public UInt32 Value()
	{
		return PSA_PsUInt4ConvertEX( m_value, 1 );
	}

	public static PsUInt4 operator + ( PsUInt4 src )
	{
		return src;
	}

	public static PsUInt4 operator - ( PsUInt4 src )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4SubNE( 0, src.m_value );
		return temp;
	}

	public static PsUInt4 operator ~ ( PsUInt4 src )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4XorEN( src.m_value, ~0u );
		return temp;
	}

	public static PsUInt4 operator ++ ( PsUInt4 src )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4AddEN( src.m_value, 1 );
		return temp;
	}
	public static PsUInt4 operator -- ( PsUInt4 src )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4SubEN( src.m_value, 1 );
		return temp;
	}

	public static PsUInt4 operator + ( PsUInt4 value1, PsUInt4 value2 )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4AddEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt4 operator + ( PsUInt4 value1, UInt32 value2 )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4AddEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt4 operator + ( UInt32 value1, PsUInt4 value2  )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4AddEN( value2.m_value, value1 );
		return temp;
	}

	public static PsUInt4 operator - ( PsUInt4 value1, PsUInt4 value2 )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4SubEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt4 operator - ( PsUInt4 value1, UInt32 value2 )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4SubEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt4 operator - ( UInt32 value1, PsUInt4 value2  )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4SubNE( value1, value2.m_value );
		return temp;
	}

	public static PsUInt4 operator * ( PsUInt4 value1, PsUInt4 value2 )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4MulEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt4 operator * ( PsUInt4 value1, UInt32 value2 )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4MulEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt4 operator * ( UInt32 value1, PsUInt4 value2  )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4MulEN( value2.m_value, value1 );
		return temp;
	}

	public static PsUInt4 operator / ( PsUInt4 value1, PsUInt4 value2 )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4DivEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt4 operator / ( PsUInt4 value1, UInt32 value2 )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4DivEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt4 operator / ( UInt32 value1, PsUInt4 value2  )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4DivNE( value1, value2.m_value );
		return temp;
	}

	public static PsUInt4 operator % ( PsUInt4 value1, PsUInt4 value2 )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4RemEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt4 operator % ( PsUInt4 value1, UInt32 value2 )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4RemEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt4 operator % ( UInt32 value1, PsUInt4 value2  )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4RemNE( value1, value2.m_value );
		return temp;
	}


	public static PsUInt4 operator << ( PsUInt4 value1, int shift )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4ShlEN( value1.m_value, (UInt32)shift );
		return temp;
	}


	public static PsUInt4 operator >> ( PsUInt4 value1, int shift )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4ShrEN( value1.m_value, (UInt32)shift );
		return temp;
	}

	public static PsUInt4 operator & ( PsUInt4 value1, PsUInt4 value2 )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4AndEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt4 operator & ( PsUInt4 value1, UInt32 value2 )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4AndEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt4 operator & ( UInt32 value1, PsUInt4 value2  )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4AndEN( value2.m_value, value1 );
		return temp;
	}

	public static PsUInt4 operator | ( PsUInt4 value1, PsUInt4 value2 )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4OrEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt4 operator | ( PsUInt4 value1, UInt32 value2 )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4OrEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt4 operator | ( UInt32 value1, PsUInt4 value2  )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4OrEN( value2.m_value, value1 );
		return temp;
	}

	public static PsUInt4 operator ^ ( PsUInt4 value1, PsUInt4 value2 )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4XorEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static PsUInt4 operator ^ ( PsUInt4 value1, UInt32 value2 )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4XorEN( value1.m_value, value2 );
		return temp;
	}

	public static PsUInt4 operator ^ ( UInt32 value1, PsUInt4 value2  )
	{
		PsUInt4 temp = new PsUInt4();
		temp.m_value = PSA_PsUInt4XorEN( value2.m_value, value1 );
		return temp;
	}

	public static bool operator == ( PsUInt4 value1, PsUInt4 value2 )
	{
		bool temp;
		temp = false != ( value1.m_value == value2.m_value );
		return temp;
	}

	public static bool operator == ( PsUInt4 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt4CeqEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator == ( UInt32 value1, PsUInt4 value2  )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt4CeqEN( value2.m_value, value1 );
		return temp;
	}

	public static bool operator != ( PsUInt4 value1, PsUInt4 value2 )
	{
		bool temp;
		temp = false != ( value1.m_value != value2.m_value );
		return temp;
	}

	public static bool operator != ( PsUInt4 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt4CeqEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator != ( UInt32 value1, PsUInt4 value2  )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt4CeqEN( value2.m_value, value1 );
		return temp;
	}

	public static bool operator < ( PsUInt4 value1, PsUInt4 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt4CltEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static bool operator < ( PsUInt4 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt4CltEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator < ( UInt32 value1, PsUInt4 value2  )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt4CltNE( value1, value2.m_value );
		return temp;
	}

	public static bool operator <= ( PsUInt4 value1, PsUInt4 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt4CgtEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static bool operator <= ( PsUInt4 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt4CgtEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator <= ( UInt32 value1, PsUInt4 value2  )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt4CgtNE( value1, value2.m_value );
		return temp;
	}

	public static bool operator > ( PsUInt4 value1, PsUInt4 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt4CgtEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static bool operator > ( PsUInt4 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt4CgtEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator > ( UInt32 value1, PsUInt4 value2  )
	{
		bool temp;
		temp = 0 !=  PSA_PsUInt4CgtNE( value1, value2.m_value );
		return temp;
	}

	public static bool operator >= ( PsUInt4 value1, PsUInt4 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt4CltEE( value1.m_value, value2.m_value );
		return temp;
	}

	public static bool operator >= ( PsUInt4 value1, UInt32 value2 )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt4CltEN( value1.m_value, value2 );
		return temp;
	}

	public static bool operator >= ( UInt32 value1, PsUInt4 value2  )
	{
		bool temp;
		temp = 0 ==  PSA_PsUInt4CltNE( value1, value2.m_value );
		return temp;
	}

}

