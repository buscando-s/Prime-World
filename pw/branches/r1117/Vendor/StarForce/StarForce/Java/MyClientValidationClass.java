//Autogenerated class implementing client validation

package MyPackageName;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import javax.crypto.IllegalBlockSizeException;

public class MyClientValidationClass implements MyClientValidationInterface
{
//==============================================================================
// ClientValidationHash00_e
//------------------------------------------------------------------------------
// Description:
//   Function for conversion of 32-bit value to 32-bit value.
//==============================================================================
static int ClientValidationHash00_e( int uValue, int uKey )
{
	byte byteTemp1, byteTemp2;
	short shortTemp1, shortTemp2;
	int intTemp1, intTemp2;
	long longTemp1, longTemp2;
	ByteBuffer uVars = ByteBuffer.allocateDirect( 8 );

	uVars.order( ByteOrder.LITTLE_ENDIAN );

	uVars.putInt( 0, uValue );
	uVars.putInt( 4, uKey );

	for( int i = 0; i <= 4; i++ )
	{
	shortTemp1 = uVars.getShort( 0 );
	shortTemp2 = uVars.getShort( 2 );
	uVars.putShort( 0, (short)(shortTemp1 ^ shortTemp2) );
	shortTemp1 = uVars.getShort( 2 );
	shortTemp2 = uVars.getShort( 4 );
	uVars.putShort( 2, (short)( shortTemp1 - shortTemp2 ) );
	intTemp1 = uVars.getInt( 0 );
	intTemp2 = uVars.getInt( 4 );
	uVars.putInt( 0, (int)( intTemp1 + intTemp2 ) );
	shortTemp2 = (short)( uVars.getShort( 6 ) & 0xF );
	shortTemp1 = uVars.getShort( 2 );
	uVars.putShort( 2, (short) ( ( ( shortTemp1 & 0xFFFF ) >>> shortTemp2 ) | ( shortTemp1 << (16 - shortTemp2 ) ) ) );
	intTemp1 = uVars.getInt( 0 );
	intTemp2 = uVars.getInt( 4 );
	uVars.putInt( 0, (int)( intTemp1 + intTemp2 ) );
	shortTemp1 = uVars.getShort( 2 );
	shortTemp2 = uVars.getShort( 6 );
	uVars.putShort( 2, (short)( shortTemp1 - shortTemp2 ) );
	intTemp2 = (int)( uVars.getInt( 4 ) & 0x1F );
	intTemp1 = uVars.getInt( 0 );
	uVars.putInt( 0, (int) ( ( intTemp1 << intTemp2 ) | ( ( intTemp1  ) >>> (32 - intTemp2 ) ) ) );
	shortTemp1 = uVars.getShort( 0 );
	shortTemp2 = uVars.getShort( 2 );
	uVars.putShort( 0, shortTemp2 );
	uVars.putShort( 2, shortTemp1 );
	}

	 return uVars.getInt(0);
}

//==============================================================================
//ClientValidationHash0
//------------------------------------------------------------------------------
//Description:
//  Function for the hash calculation.
//==============================================================================
void ClientValidationHash0( byte[] input, byte[] output)
{

	int i,k;
	int Hi,Mi,uResult;
	int sizeOfInt = 4;

	ByteBuffer buf = ByteBuffer.allocateDirect( 32 );
	buf.order( ByteOrder.LITTLE_ENDIAN );
	ByteBuffer out_buf = ByteBuffer.allocateDirect( 32 );
	out_buf.order( ByteOrder.LITTLE_ENDIAN );
	int uInBufferSize = input.length;
	int uKey = 0x323C1A47;

	for( i = 0; i < 8; i++ ) out_buf.putInt( i * sizeOfInt, 0 );

	Hi = uKey;
	for( i = 0; i < uInBufferSize; i += 8 * sizeOfInt )
	{
		for( k = 0; k < 8; k++ ) buf.putInt( k * sizeOfInt, 0 );
		if ( ( i + ( 8 * 4 ) ) < uInBufferSize )
		{
			buf.position( 0 );
			buf.put( input, i, 8 * sizeOfInt );
		}
		else
		{
			buf.position( 0 );
			buf.put( input, i, uInBufferSize - i );
		}
		for( k = 0; k < 8; k++ )
		{
			Mi = buf.getInt( k * sizeOfInt );
			Hi ^= out_buf.getInt( k * sizeOfInt );
			uResult = Mi ^ Hi;
			uResult = ClientValidationHash00_e( uResult, Hi );
			Hi = (uResult << 5) ^ (uResult >>> 5) ^ Mi ^ Hi;
			out_buf.putInt( k * sizeOfInt, Hi );
		}
	}

	ByteBuffer outputWrap = ByteBuffer.wrap( output );
	outputWrap.order( ByteOrder.LITTLE_ENDIAN );
	for( i = 0; i < 4; i++ )
	{
		int Hi_rotated = ( Hi << 1 ) | ( Hi >>> 31 );
		Hi = Hi_rotated;
		outputWrap.putInt( i* sizeOfInt,  out_buf.getInt( i * sizeOfInt ) ^ Hi_rotated );
	}

	return;
}

	public static final int PSA_VALIDATE_CLIENT_BUFFER_SIZE = 16;
	public int getBlockSize(){ return PSA_VALIDATE_CLIENT_BUFFER_SIZE; }
	public byte[] MyDataProcessingFunction( byte[] data ) throws IllegalBlockSizeException
	{
		if( data.length != PSA_VALIDATE_CLIENT_BUFFER_SIZE ) throw new IllegalBlockSizeException( "Length of data block must be PSA_VALIDATE_CLIENT_BUFFER_SIZE" );
		byte[] result = new byte[PSA_VALIDATE_CLIENT_BUFFER_SIZE];
		ClientValidationHash0( data, result );
		return result;
	}
}
