//
//	PscApi.h
//
//	File description:
//		Header file for core API functions. These functions can be used in
//      initialization module. These functions MUST NOT be used in protected
//		application.
//

// Include this file only once
#pragma once

#ifdef NOIMPORTPSAPI
#define PSAPI __stdcall
#else
#define PSAPI __declspec(dllimport) __stdcall
#endif

// Additional headers
#ifndef PS_CONFIG_H_INCLUDED_7D7370D6_8681_4908_8C5F_D1152CF38653
#define PS_CONFIG_H_INCLUDED_7D7370D6_8681_4908_8C5F_D1152CF38653
#include "PsConfig.h"
#endif
#ifndef PS_CONSTANTS_H_INCLUDED_7990EBEC_1968_44FF_AF44_6800920821F1
#define PS_CONSTANTS_H_INCLUDED_7990EBEC_1968_44FF_AF44_6800920821F1
#include "PsConstants.h"
#endif

//
//	Common initialization functions
//

// Start initialization (first service)
unsigned __int32 PSAPI PSC_StartInitialization(
	unsigned __int32 initializationType );

// Finish initialization
unsigned __int32 PSAPI PSC_FinishInitializationSuccess();

// Finish initialization
unsigned __int32 PSAPI PSC_FinishInitializationFailure();

// Uninitialization (last service)
unsigned __int32 PSAPI PSC_Uninitialize();

// Additional initialization at valid license
unsigned __int32 PSAPI PSC_PerformInitializationAtValidLicense();

#ifdef PS_MQL4_PROTECT
unsigned __int32 PSAPI PSC_PerformInitializationMQL4();
unsigned __int32 PSAPI PSC_ReInitializeMql4();
#endif

// Initialization in demo mode
#ifdef PS_DEMO_MODE_SUPPORTED
unsigned __int32 PSAPI PSC_InitializeDemoMode();
#endif

//
//	Miscellaneous functions
//

// Get detailed error information
unsigned __int32 PSAPI PSC_GetErrorInformation(
	unsigned __int32 *infoBuffer,
	size_t *infoBufferSizeInElements,
	char *usedKeyBuffer,
	size_t *usedKeyBufferSizeInChars );

// Get detailed error information
#ifdef OPTION_DATA_FILES_PROTECTION
unsigned __int32 PSAPI PSC_GetDocumentGuidHash(
	char *documentGuidHashBuffer );
#endif

// Get license identifier
#ifdef PS_USE_LICENSES
unsigned __int32 PSAPI PSC_GetLicenseId(
	unsigned __int32 *identifier );
#endif

// Load localized string
unsigned __int32 PSAPI PSC_LoadString(
	unsigned __int32 stringId,
	wchar_t *stringBuffer,
	size_t *stringBufferSizeInWideChars );

// Perform activation automatically
#if ( defined PS_HARDWARE_BASED_INITIALIZATION_SUPPORTED || defined PS_DISC_WITH_BACKUP_BASED_INITIALIZATION_SUPPORTED ) && defined PS_AUTO_ACTIVATION_ENABLED
unsigned __int32 PSAPI PSC_ActivateAutomatically(
	const wchar_t *serialNumber,const wchar_t *hardwareCode, BOOL activate,
	wchar_t *activationKey, size_t *activationKeySizeInWideChars,
	wchar_t *activationMessage, size_t *activationMessageSizeInWideChars,
	wchar_t *supportInformation, size_t *supportInformationSizeInWideChars );
#endif

// Enter global critical section (for license access)
unsigned __int32 PSAPI PSC_EnterGlobalCriticalSection();

// Leave global critical section (for license access)
unsigned __int32 PSAPI PSC_LeaveGlobalCriticalSection();

//
//	Functions for disc-based initialization
//

#if defined PS_DISC_BASED_INITIALIZATION_SUPPORTED || defined PS_DISC_WITH_BACKUP_BASED_INITIALIZATION_SUPPORTED

// Set preferred drive letter
unsigned __int32 PSAPI PSC_DiscSetPreferredDrive( 
	wchar_t driveLetter );

// Search disc and get label
unsigned __int32 PSAPI PSC_DiscSearchDisc2(
	char *labelBuffer,
	size_t *labelBufferSize,
	unsigned __int32 *type );

// Try to load disc license from registry
unsigned __int32 PSAPI PSC_DiscLoadLicenseFromRegistry(
	char *keyBuffer,
	size_t *keyBufferSize );

// Try to create disc license based on key written on the disc
unsigned __int32 PSAPI PSC_DiscCreateLicenseFromDisc();

// Test key and if it is valid create license and write it into system registry
unsigned __int32 PSAPI PSC_DiscTestNewKeyAndWriteLicenseForValidDiscKey(
	const char *key );

// Try rescue license (optionally preserve existed disc license)
unsigned __int32 PSAPI PSC_DiscTryRescueLicense(
	bool restoreExistedDiscLicenseOnError );

// Create or load rescue license and get hardware code
unsigned __int32 PSAPI PSC_DiscCreateOrLoadRescueLicenseAndGetHardwareCode(
	char *hardwareCodeBuffer,
	size_t *hardwareCodeBufferSize );

// Activate loaded rescue license
unsigned __int32 PSAPI PSC_DiscActivateAndStoreRescueLicense(
	const char *key );

// Try disc license (i.e. check disc)
unsigned __int32 PSAPI PSC_DiscTryDiscLicense();

// Create autogenerated license
#ifdef PS_BIND_TO_HARDWARE_AFTER_CD_SUCCESS
unsigned __int32 PSAPI PSC_DiscCreateAutogeneratedLicense();
#endif

// Try to check autogenerated license
#ifdef PS_BIND_TO_HARDWARE_AFTER_CD_SUCCESS
unsigned __int32 PSAPI PSC_DiscTryAutogeneratedLicense();
#endif

unsigned __int32 PSAPI PSC_DiscIsPreviousDiscCheckCrashed(
	bool *crashDetected );

#endif

//
//	Functions for computer-based initalization (activation)
//

#if defined PS_HARDWARE_BASED_INITIALIZATION_SUPPORTED || defined PS_DISC_WITH_BACKUP_BASED_INITIALIZATION_SUPPORTED

// Try to create/check trial license
#ifdef PS_TRIAL_PERIOD_SUPPORTED
unsigned __int32 PSAPI PSC_HardwareTryTrialLicense(
	bool createIfAbsent );
#endif

// Validate entered license number
unsigned __int32 PSAPI PSC_ValidateLicenseNumber(
	const char *licenseNumber,
	unsigned __int32 encodingId[ 4 ] );

// Try to check normal license (always resets previous license, on success sets new current license)
unsigned __int32 PSAPI PSC_HardwareTryNormalLicense(
	const char *licenseNumber );

#ifdef PS_SUM_LICENSES

// License position flags
#define PSC_PositionTypeFirst	1
#define PSC_PositionTypeLast	2

// Try and sum normal license (on error preserves previos lisense, on success adds current license data
// to previous and sets current lisense)
unsigned __int32 PSAPI PSC_HardwareAddNormalLicense(
	const char *licenseNumber, unsigned __int32 positionType );

#endif

// Create or load license, get hardware code
unsigned __int32 PSAPI PSC_HardwareCreateOrLoadNormalLicenseAndGetHardwareCode(
	const char *licenseNumber,
	char *hardwareCodeBuffer,
	size_t *hardwareCodeBufferSize );

// Activate current license
unsigned __int32 PSAPI PSC_HardwareActivateAndStoreNormalLicense(
	const char *key );

// Deactivate current license
#ifdef OPTION_ENABLE_DEACTIVATION
unsigned __int32 PSAPI PSC_HardwareDeactivateLicense( 
	const char *licenseNumber,
	char *hardwareCodeBuffer,
	size_t *hardwareCodeBufferSize );
#endif

#endif

//
//	Functions for local server-based initialization
//

#ifdef PS_SERVER_BASED_INITIALIZATION_CLIENT

// Initialize new session
unsigned __int32 PSAPI PSC_SrvBndClientInitializeSession(
	UUID sessionGuid );

// Start session (get or restore license from server)
unsigned __int32 PSAPI PSC_SrvBndClientStartSession();

// Approve session
unsigned __int32 PSAPI PSC_SrvBndClientApproveSession();

// Finish and deinitialize session (get license back to the server and free resources)
unsigned __int32 PSAPI PSC_SrvBndClientFinishAndDeinitializeSession();

#endif

#ifdef PS_SERVER_BASED_INITIALIZATION_SERVER

// Process request
unsigned __int32 PSAPI PSC_SrvBndServerProcessRequest(
	unsigned __int32 languageId,
	char *requestDataBuffer,
	size_t requestDataBufferSize,
	char *responseDataBuffer,
	size_t *responseDataBufferSize );

#endif

//
//	Functions for remote server-based initialization
//

#ifdef PS_REMOTE_SERVER_BASED_INITIALIZATION_SUPPORTED

// Start new session
unsigned __int32 PSAPI PSC_RemoteServerStartSession();

#endif

//
//	Functions for external binding initialization
//

#ifdef PS_EXTERNAL_BASED_INITIALIZATION_SUPPORTED

// Perform external binding check
unsigned __int32 PSAPI PSC_ExternalBindingCheck();

#endif

//
//	Hidden info remover (these functions are not accessible in user interface project)
//

#ifdef TRIAL_INFO_REMOVER

#ifdef PS_USE_LICENSES

// Remove trial information
#ifdef PS_TRIAL_PERIOD_SUPPORTED
unsigned __int32 PSAPI PSC_RemoveTrial();
#endif

// Remove history of license usage (number of runs, time of last run etc.)
unsigned __int32 PSAPI PSC_RemoveHistory();

// Remove all licenses including history
unsigned __int32 PSAPI PSC_RemoveAllLicenses();

// Remove hidden information about deactivated licenses
unsigned __int32 PSAPI PSC_RemoveHiddenDeactivationInfo();

#endif

#ifdef PS_SUPPORT_CERTIFICATE_CHECK

// Generate certificate
unsigned __int32 PSAPI PSC_CertificateGenerate( unsigned __int64 startDate, unsigned __int64 finishDate, const wchar_t* certSignSeedGuidStr, const char* certEmbedData, const unsigned __int16 certEmbedDataSize, const wchar_t *certFileName );

#endif

#endif

//
//	Protection of documents
//

#ifdef OPTION_DATA_FILES_PROTECTION

#ifdef PS_DISC_BASED_INITIALIZATION_SUPPORTED

// Try to open document
unsigned __int32 PSAPI PSC_DiscCheckDocument(
	HANDLE fileHandle,
	unsigned __int32 documentId[ 4 ],
	unsigned __int32 *errorCode );

// Try to check rescue license
unsigned __int32 PSAPI PSC_DiscTryRescueDocumentLicense(
	bool restoreExistedDiscLicenseOnError,
	HANDLE fileHandle,
	unsigned __int32 documentId[ 4 ],
	unsigned __int32 *errorCode );

// Try to check disc license
unsigned __int32 PSAPI PSC_DiscTryDocumentLicense(
	HANDLE fileHandle,
	unsigned __int32 documentId[ 4 ],
	unsigned __int32 *errorCode );

#endif

#ifdef PS_HARDWARE_BASED_INITIALIZATION_SUPPORTED

// Try to open document
unsigned __int32 PSAPI PSC_HardwareCheckDocument(
	HANDLE fileHandle,
	unsigned __int32 documentId[ 4 ],
	char *licenseNumber,
	unsigned __int32 *errorCode );

// Try to check normal license
unsigned __int32 PSAPI PSC_HardwareTryDocumentLicense(
	HANDLE fileHandle,
	unsigned __int32 documentId[ 4 ],
	const char *licenseNumber,
	unsigned __int32 *errorCode );

// Create or load license, get hardware code
unsigned __int32 PSAPI PSC_HardwareCreateOrLoadDocumentLicenseAndGetHardwareCode(
	unsigned __int32 documentId[ 4 ],
	const char *licenseNumber,
	char *hardwareCodeBuffer,
	size_t *hardwareCodeBufferSize );

// Activate current license
unsigned __int32 PSAPI PSC_HardwareActivateAndStoreDocumentLicense(
	const char *key );

#ifdef OPTION_ENABLE_DEACTIVATION
unsigned __int32 PSAPI PSC_HardwareDeactivateDocumentLicense(
	HANDLE fileHandle,
	unsigned __int32 documentId[ 4 ],
	const char *licenseNumber,
	char *hardwareCodeBuffer,
	size_t *hardwareCodeBufferSize );
#endif

#endif

// Open protected document (complex function implemented in user interface project)
// Return values:
//   PSC_STATUS_SUCCESS - success
//   PSC_STATUS_BAD_FORMAT - the file is not protected document
//   Other return values for errors are also possible
unsigned __int32 PSAPI PSC_DocumentOpen( HANDLE documentFile );

#endif

//
//	Protection of documents (these functions are not accessible in user interface project)
//

#ifdef OPTION_DATA_FILES_PROTECTION

// Get size of protected document (hidden function: not exported from protect.dll in final version)
// Return values:
//   PSC_STATUS_SUCCESS - success (documentSize contains size of document)
//   Other return values for errors are also possible
unsigned __int32 PSAPI PSC_DocumentGetSize( HANDLE documentFile, size_t *documentSize );

// Get data (hidden function: not exported from protect.dll in final version)
// Return values:
//   PSC_STATUS_SUCCESS - success (dataBuffer will contain decrypted data block)
//   Other return values for errors are also possible
unsigned __int32 PSAPI PSC_DocumentGetData( HANDLE documentFile, void *dataBuffer, size_t dataOffset, size_t dataSize );

// Close protected document (hidden function: not exported from protect.dll in final version)
// Return values:
//   PSC_STATUS_SUCCESS - success
//   Other return values for errors are also possible
unsigned __int32 PSAPI PSC_DocumentClose( HANDLE documentFile );

#endif

//
//	External License Management
//

// Protocol version and packet types
#define PSC_ELM_PROTOCOL_VERSION_0								0
#define PSC_ELM_PACKET_TYPE_INITIALIZE							0	// For PSC_ElmInitializationPacket
#define PSC_ELM_PACKET_TYPE_MESSAGE								1	// For PSC_ElmMessagePacket
#define PSC_ELM_PACKET_TYPE_WARNING								2	// For PSC_ElmMessagePacket
#define PSC_ELM_PACKET_TYPE_ERROR								3	// For PSC_ElmMessagePacket
#define PSC_ELM_PACKET_TYPE_LICENSE_EXPIRED						4	// For PSC_ElmMessagePacket
#define PSC_ELM_PACKET_TYPE_REMOTE_SERVER_ACTIVATION_REQUEST	5	// For PSC_ElmRemoteServerActivationRequestPacket
#define PSC_ELM_PACKET_TYPE_REMOTE_SERVER_ACTIVATION_RESPONSE	6	// For PSC_ElmRemoteServerActivationResponsePacket

// Packet size
#define PSC_ELM_PACKET_MAX_SIZE									1024

// Base packet for exchange with loader (in application mode)
struct PSC_ElmPacket
{
	unsigned __int32	ProtocolVersion;
	unsigned __int32	PacketType;
	unsigned __int32	ProcessId;
};

// Initialization packet (loader <- application)
struct PSC_ElmInitializationPacket
{
	PSC_ElmPacket		PacketHeader;
	BYTE				ProjectGuidHash[ PS_PROJECT_GUID_HASH_SIZE ];	
};

// Message packet (loader <- application)
struct PSC_ElmMessagePacket
{
	PSC_ElmPacket		PacketHeader;
	wchar_t				Message[ 1 ];		// Zero-terminated string of variable length
};

// Serial number packet (loader -> application), for remote server initialization only
struct PSC_ElmRemoteServerActivationRequestPacket
{
	PSC_ElmPacket		PacketHeader;
	wchar_t				SerialNumber[ 1 ];	// Zero-terminated string of variable length
};

// Status packet (loader <- application), for remote server initialization only
struct PSC_ElmRemoteServerActivationResponsePacket
{
	PSC_ElmPacket		PacketHeader;
	unsigned __int32	Status;
	wchar_t				Message[ 1 ];		// Zero-terminated string of variable length
};

//
// Periodical IAT check
//

// Perform IAT check
// Return values:
//   PSC_STATUS_SUCCESS - success, IAT is correct
//	 Other return value - failure, IAT is modified
#ifdef OPTION_ENABLE_PERIODICAL_CHECK_OF_IAT_FOR_PROTECTED_MODULES 
unsigned __int32 PSAPI PSC_CheckIatCrcForProtectedModules();
#endif
